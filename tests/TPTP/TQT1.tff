% time and temporal reasoning

tff(worlds_tp,type,
    w: $tType ).

tff(modals_tp,type,
    m: $tType ).

tff(desires_tp,type,
    desires: m ).

tff(knows_tp,type,
    knows: m ).
        
tff(holdsDuring_tp,type,
    holdsDuring: m ).
   
tff(confersObligation_tp,type,
    confersObligation: m ).
   
tff(employs_tp,type,
    employs: ($i * $i * w )> $o ).
                
tff(agent_tp,type,
    agent: ($i * $i * w) > $o ).

tff(patient_tp,type,
    patient: ($i * $i * w) > $o ).

tff(destination_tp,type,
    destination: ($i * $i * w) > $o ).

tff(plaintiff_tp,type,
    plaintiff: ($i * $i * w) > $o ).
    
tff(defendant_tp,type,
    defendant: ($i * $i * w) > $o ).
        
tff(victim_tp,type,
    victim: ($i * $i * w) > $o ).

tff(suffers_tp,type,
    suffers: ($i * $i * w) > $o ).
    
tff(earlier_tp,type,    % Doesn't need a world.  Assume basic physics in all worlds. Time can't go backwards.
    earlier: ($i * $i) > $o ).
        
tff(meetsTemporally_tp,type,    % Doesn't need a world.  Assume basic physics in all worlds. Time can't go backwards.
    meetsTemporally: ($i * $i) > $o ).
            
tff(during_tp,type,     % Doesn't need a world.  Assume basic physics in all worlds.
    during: ($i * $i) > $o ).
            
tff(whenFn_tp,type,
    whenFn: ($i * w) > $i ).

tff(pastFn_tp,type,    % Doesn't need a world.  Assume basic physics in all worlds.
    pastFn: ($i) > $i ).
    
tff(futureFn_tp,type,  % Doesn't need a world.  Assume basic physics in all worlds.
    futureFn: ($i) > $i ).

tff(immediatePastFn_tp,type,    % Doesn't need a world.  Assume basic physics in all worlds.
    immediatePastFn: ($i) > $i ).
    
tff(immediateFutureFn_tp,type,  % Doesn't need a world.  Assume basic physics in all worlds.
    immediateFutureFn: ($i) > $i ).

tff(addDayFn_tp,type,
    addDayFn: ($int * $i) > $i ).            
    
tff(dayFn_tp,type,
    dayFn: ($int * $i) > $i ).
    
tff(monthFn_tp,type,
    monthFn: ($i * $i) > $i ).
        
tff(yearFn_tp,type,
    yearFn: ($int) > $i ).

tff(hourFn_tp,type,
    hourFn: ($int * $i) > $i ).
    
tff(minuteFn_tp,type,
    minuteFn: ($int * $i) > $i ).
    
tff(secondFn_tp,type,
    secondFn: ($int * $i) > $i ).
            
tff(governmentFn_tp,type,   % definitional, doesn't need a world
    governmentFn: ($i) > $i ).
                    
tff(attribute_tp,type,
    attribute: ($i * $i * w) > $o ).

tff(subOrganization_tp,type,
    subOrganization: ($i * $i * w) > $o ).
    
tff(instance_tp,type,       % constant domains, doesn't need a world
    instance: ($i * $i) > $o ).

tff(mIBUnit_tp,type,
    mIBUnit: $i ).
    
tff(organization_tp,type,
    organization: $i ).

tff(uSGovernment_tp,type,
    uSGovernment: $i ).
            
tff(unitedStates_tp,type,
    unitedStates: $i ).
                
tff(human_tp,type,
    human: $i ).

tff(agentSmith_tp,type,
    agentSmith: $i ).

tff(facility_tp,type,
    facility: $i ).
        
tff(area51_tp,type,
    area51: $i ).
        
tff(legalAction_tp,type,
    legalAction: $i ).
     
tff(entering_tp,type,
    entering: $i ).
    
tff(terminatingEmployment_tp,type,
    terminatingEmployment: $i ).    
                
tff(accreln_tp,type,
    accreln: (m * $i * w * w) > $o ).

tff(accreln2_tp,type,
    accreln2: (m * $i * $i * w * w) > $o ).
    
tff(currentworld_tp,type,
    cw: w ).

tff(month_tp,type,
  month: $i).
  
tff(succClass_tp,type,
  successorClass: ($i * $i) > $o).  
  
tff(daysInMonth_tp,type,
  daysInMonth: ($int * $i) > $o).
    
tff(jan_tp,type,
  january: $i).
tff(janDays_tp,axiom,
  daysInMonth(31,january)).
  
tff(feb_tp,type,
  february: $i).  
tff(februaryDays_tp,axiom,
  daysInMonth(28,february)).
  
tff(mar_tp,type,
  march: $i).
tff(marchDays_tp,axiom,
  daysInMonth(31,march)).
    
tff(apr_tp,type,
  april: $i).
tff(aprilDays_tp,axiom,
  daysInMonth(30,april)).
    
tff(may_tp,type,
  may: $i).
tff(mayDays_tp,axiom,
  daysInMonth(31,may)).
    
tff(jun_tp,type,
  june: $i).
tff(juneDays_tp,axiom,
  daysInMonth(30,june)).
    
tff(july_tp,type,
  july: $i).
tff(julyDays_tp,axiom,
  daysInMonth(31,july)).
    
tff(aug_tp,type,
  august: $i).
tff(augustDays_tp,axiom,
  daysInMonth(31,august)).
    
tff(sep_tp,type,
  september: $i).
tff(septemberDays_tp,axiom,
  daysInMonth(30,september)).
    
tff(oct_tp,type,
  october: $i).
tff(octoberDays_tp,axiom,
  daysInMonth(31,october)).
    
tff(nov_tp,type,
  november: $i).
tff(novemberDays_tp,axiom,
  daysInMonth(30,november)).
    
tff(dec_tp,type,
  december: $i).
tff(decemberDays_tp,axiom,
  daysInMonth(31,december)).
    

tff(succJan,axiom,
  successorClass(january, february)).
tff(succFeb,axiom,
  successorClass(february, march)).
tff(succMar,axiom,
  successorClass(march, april)).
tff(succApr,axiom,
  successorClass(april, may)).
tff(succMay,axiom,
  successorClass(may, june)).
tff(succJun,axiom,
  successorClass(june, july)).
tff(succJul,axiom,
  successorClass(july, august)).
tff(succAug,axiom,
  successorClass(august, september)).
tff(succSep,axiom,
  successorClass(september, october)).
tff(succOct,axiom,
  successorClass(october, november)).
tff(succNov,axiom,
  successorClass(november, december)).

tff(succTrans,axiom,
  (![C1:$i,C2:$i,C3:$i]:(
    (successorClass(C1, C2) &
     successorClass(C2, C3)) =>
       successorClass(C1, C3))) ).
             
tff(def1,axiom,
  instance(agentSmith, human)).
  
tff(def2,axiom,
  instance(area51, facility)).
      
% time stuff.  Temporal relations between times are true in all worlds

tff(duringDay,axiom,
  (![D:$int,M:$i,T1:$i,T2:$i,Y:$int]:(
    ((T1 = dayFn(D, monthFn(M, yearFn(Y)))) &
     (T2 = monthFn(M, yearFn(Y)))) =>
       during( T1, T2)))).

tff(duringDayYear,axiom,
  (![D:$int,M:$i,T1:$i,T2:$i,Y:$int]:(
    ((T1 = dayFn( D, monthFn( M, yearFn( Y)))) &
     (T2 = yearFn( Y))) =>
       during( T1, T2)))).
       
tff(duringMonth,axiom,
  (![M:$i,T1:$i,T2:$i,Y:$int]:(
    ((T1 = monthFn( M, yearFn( Y))) &
     (T2 = yearFn( Y))) =>
       during( T1, T2)))).
              
tff(earlierMonth,axiom,
  (![M1:$i,M2:$i,T1:$i,T2:$i,Y:$int]:(
    (successorClass( M1, M2) &
     (T1 = monthFn( M1, yearFn( Y))) &
     (T2 = monthFn( M2, yearFn( Y)))) =>
       earlier( T1, T2)))).

tff(earlierMonthDay,axiom,
  (![D1:$int,D2:$int,M1:$i,M2:$i,T1:$i,T2:$i,Y:$int]:(
    (successorClass( M1, M2) &
     (T1 = dayFn( D1, monthFn( M1, yearFn( Y)))) &
     (T2 = dayFn( D2, monthFn( M2, yearFn( Y))))) =>
       earlier( T1, T2)))).
       
tff(earlierYear,axiom,
  (![T1:$i,T2:$i,Y1:$int,Y2:$int]:(
    (($less(Y1, Y2) &
     (T1 = yearFn(Y1)) &
     (T2 = yearFn(Y2))) =>
       earlier(T1, T2))))).
              
tff(earlierYearMonth,axiom,
  (![M1:$i,M2:$i,T1:$i,T2:$i,Y1:$int,Y2:$int]:(
    (($less(Y1, Y2) &
     (T1 = monthFn( M1, yearFn( Y1))) &
     (T2 = monthFn( M2, yearFn( Y2)))) =>
       earlier(T1, T2))))).

tff(earlierYearDay,axiom,
  (![D1:$int,D2:$int,M1:$i,M2:$i,T1:$i,T2:$i,Y1:$int,Y2:$int]:(
    (($less(Y1, Y2) &
     (T1 = dayFn( D1, monthFn(M1, yearFn( Y1)))) &
     (T2 = dayFn( D2, monthFn( M2, yearFn(Y2))))) =>
       earlier(T1, T2))))).

tff(earlierDay,axiom,
  (![D1:$int,D2:$int,M:$i,T1:$i,T2:$i,Y:$int]:(
    (($less(D1, D2) &
     (T1 = dayFn( D1, monthFn(M, yearFn( Y)))) &
     (T2 = dayFn( D2, monthFn(M, yearFn( Y))))) =>
       earlier(T1, T2))))).
                       

%tff(addDayRecurse,axiom,
%  ![D1:$int,D2:$int,D3:$int,D4:$int,DM:$int,M:$i,M2:$i,Y:$int]:(
%    (D3 = $sum(D1,D2) &
%     daysInMonth(DM,M) &
%     successorClass(M,M2) &
%     $greater($sum(D1,D2),DM) &
%     (D4 = $difference(DM,D2))) &
%       (dayFn(D4,monthFn(M2,yearFn(Y))) = 
%        addDayFn(D2,dayFn(D1,monthFn(M,yearFn(Y))))))).
        
tff(addDay,axiom,
  ![D1:$int,D2:$int,D3:$int,DM:$int,M:$i,Y:$int]:(
    ((dayFn(D3,monthFn(M,yearFn(Y))) = 
        addDayFn(D2,dayFn(D1,monthFn(M,yearFn(Y))))) &
        daysInMonth(DM,M) &
        $less($sum(D1,D2),DM)) =>
    (D3 = $sum(D1,D2)))).

 % The loan is due 3 days after Dec 25th, 1980.  What is that date?
   
% works in vampire with -qa plain   
% SZS answers Tuple [[28,december,1980]|_] for TQT1   
%tff(conj,conjecture,  
%  ?[D:$int,M:$i,Y:$int]:(
%  (dayFn(D,monthFn(M,yearFn(Y))) =
%    addDayFn(3,dayFn(25,monthFn(december,yearFn(1980))))))).

 % The loan is due 30 days after Nov 25th, 1980.  What is that date?
% not working
  
tff(conj,conjecture, % check all the premises     
  ![D1:$int,D2:$int,D3:$int,D4:$int,DM:$int,D:$int,M:$i,M2:$i,Y:$int,DATE:$i]:(
%     (D3 = $sum(D1,D2)) &
     daysInMonth(DM,November) &
%     successorClass(M,M2) &
%     $greater($sum(D1,D2),DM) &
%     (D4 = $difference(DM,D2)) &
%     (dayFn(D,monthFn(M,yearFn(Y))) =
      (dayFn(D3,monthFn(M,yearFn(Y))) = 
      addDayFn(3,dayFn(25,monthFn(December,yearFn(1980))))))).
          
%tff(conj,conjecture,  
%  ?[D:$int,M:$i,Y:$int]:(
%  (dayFn(D,monthFn(M,yearFn(Y))) =
%    addDayFn(30,dayFn(25,monthFn(november,yearFn(1980))))))).
         
 % The loan is due 90 days after Dec 25th, 1980.  What is that date?
     
     
% Question 1: If January 1st, 2023, is a Sunday, what day of the week will October 31st, 2023?

%Solution: 

%To solve this problem, we need to count the number of days between January 1st, 2023, and October 31st, 2023, and then find out what day of the week October 31st, 2023, falls on.
%Total number of days between January 1st, 2023, and October 31st, 2023 = 30 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 = 303 
%Now, we can find out what day of the week October 31st, 2023, falls on by adding 303 days to Sunday, which is the day of the week on January 1st, 2023.
%303 divided by 7 leaves a remainder of 2, which means that 304 days after Sunday is two days after Sunday, which is Tuesday. 
%Therefore, October 31st, 202,3 is on a Tuesday.

%Question 2: If March 1st, 2024, is a Friday, what day of the week will be September 1st, 2024?

%Solution: 

%To solve this problem, we need to count the days between March 1st, 2024, and September 1st, 2024, and then find out what day of the week September 1st, 2024 falls on. 
%A total number of days = 30 + 30 + 31 + 30 + 31 + 31 + 1 = 184 
%Now, we can find out what day of the week September 1st, 2024 falls on by adding 184 days to Saturday, which is the day of the week on March 1st, 2024. 
%184 divided by 7 leaves a remainder of 2, which means that 184 days after Friday is second day after Friday, which is Sunday. 
%Therefore, September 1st, 2024 is on Sunday.

%Question 3: What was the day of 14 April 2000? 

%Solution : 

%1600 will have 0 odd days. 300 years will have 1 odd day. 
%Now, in the next 99 years, we would be having 75 non-leap years and 24 leap years.
%Number of odd days = (75 x 1) + (24 x 2) = 75 + 48 = 123 mod 7 = 4 odd days 
%Total odd days till now = 1 + 4 = 5 
%Number of odd days in January = 31 mod 7 = 3 
%Number of odd days in February (2000 is a leap year) = 29 mod 7 = 1 
%Number of odd days in March = 31 mod 7 = 3 
%Number of odd days till 14 April 2000 in the month of April= 14 mod 7 = 0 
%So, the total number of odd days = 5 + 3 + 1 + 3 = 12 mod 7 = 5 
%Thus, 14 April 2000 was Friday (odd days = 5 => Friday)   

%Question 4: What was the day on 16 August 1947? 

%Solution: 

%1600 will have 0 odd days. 
%300 years will have 1 odd day. 
%Now, in the next 46 years, we would be having 35 non-leap years and 11 leap years. 
%Number of odd days = (35 x 1) + (11 x 2) = 35 + 22 = 57 mod 7 = 1 odd days 
%Total odd days till now = 1 + 1 = 2 
%Number of odd days in January = 31 mod 7 = 3 
%Number of odd days in February (1947 is a non - leap year) = 28 mod 7 = 0 
%Number of odd days in March = 31 mod 7 = 3 
%Number of odd days in April = 30 mod 7 = 2 
%Number of odd days in May = 31 mod 7 = 3 
%Number of odd days in June = 30 mod 7 = 2 
%Number of odd days in July = 31 mod 7 = 3
%Number of odd days till 16 August 1947 = 16 mod 7 = 2 
%So, the total number of odd days = 2 + 3 + 0 + 3 + 2 + 3 + 2 + 3 + 2 = 20 mod 7 = 6 
%Thus, 16 August 1947 was Saturday (odd days = 6 => Saturday)

%Question 5: If 1st January 2000 was a Saturday, what day of the week was 1st January 2010?

%Solution:

%To determine the day of the week for January 1st, 2010, given that January 1st, 2000 was a Saturday, we need to calculate the number of days that passed from January 1st, 2000 to January 1st, 2010. Then, we can find the remainder when divided by 7 (since a week has 7 days).

%Number of years between 2000 and 2010:
%From January 1st, 2000 to January 1st, 2010, there are exactly 10 years.
%Leap years between 2000 and 2010: 2000, 2004, 2008.
%Days Calculation:
%A normal year has 365 days.
%A leap year has 366 days.
%So, for 10 years:
%7 normal years: 7 × 365 = 2,555 days
%3 leap years: 3 × 366 = 1,098 days
%Total number of days: 2,555+ 1,098 = 3,653 days
%Now, we find the remainder : 3653 % 7 = 6
%Since the remainder is 6, we move 6 days forward from Saturday which is friday.

%Question 6: What was the day of the week on 26th January 1950?

%Solution:

%To determine the day of the week on 26th January 1950, we start from the base date of 1st January 1900 and calculate the total number of odd days up to this date. 
%Between 1900 and 1949, there are 50 years, consisting of 12 leap years and 38 ordinary years. 
%Leap years add 2 odd days each, while ordinary years contribute 1 odd day each, giving us 12 × 2 + 38 × 1 = 24 + 38 = 62 odd days. 
%Dividing 62 by 7, we get a remainder of 6, meaning there are 6 odd days from the years.

%Now, let’s count the odd days from the months in 1950 up to January 26.
%January contributes 3 odd days up to the 26th. 
%Adding the 6 odd days from the years to the 3 odd days from January gives us a total of 9 odd days, which simplifies to 2 odd days when divided by 7. 
%Starting from Monday (1st January 1900), two odd days ahead bring us to Thursday. 
%Thus, 26th January 1950 was a Thursday.

%Question 7: What day of the week was 29th February 2016?

%Solution:

%Since 29th February 2016 is within a leap year, we can calculate the day of the week by starting from a known reference date like 1st January 2000, which was a Saturday. We need to calculate the number of odd days from 2000 to 2016.

%From 2000 to 2015, there are 16 years, with 4 leap years (2004, 2008, 2012, and 2016) and 12 ordinary years. The leap years contribute 4 × 2 = 8 odd days, and the ordinary years contribute 12 × 1 = 12 odd days. 
%The total number of odd days is 8 + 12 = 20, which leaves a remainder of 6 when divided by 7.

%Now, counting from Saturday, 6 odd days take us to Friday. Since 29th February is in 2016, we add 1 more day (for January and February leading up to the 29th). This final day brings us to Saturday. 
%Hence, 29th February 2016 was a Monday.

%Question 8: Today ( 05-05-2025) is Monday. In 96 days, what day will it be?

%Solution:

%Find the remainder when 96 is divided by 7
96 % 7 = 5

%Count 5 days forward from Monday, it will be Saturday.

%So, 96 days after May 5th, 2025 (Monday) will be a Saturday.               

     
