% ==============================================================================
%%             Adam Pease (CS), Pante Stanica (Math), NPS
% ==============================================================================
%  VAMPIRE UNIVERSAL SYSTEM: DATES + TIME + SCHEDULER
% ==============================================================================
%  This file implements a full Gregorian Calendar system in First-Order Logic.
%  It includes:
%    1. Date Arithmetic (Forward/Backward across years/leap years).
%    2. Time Arithmetic (Minutes/Hours rollover).
%    3. Universal Weekday Calculation (Zeller's Congruence).
%    4. Scheduler Logic (e.g., "Find the 2nd Thursday of Nov 2025").
% run it with: vampire-main -qa plain --mode casc --time_limit 400 <FileName_DateArithmetic>.tff 2>&1 | grep "^% SZS answers"
% ==============================================================================

% --- 1. TYPES ---
% We define specific types to keep the logic clean.
tff(t_date, type, date: $tType).
tff(t_ymd,  type, ymd: ($int * $int * $int) > date).      % Constructor: ymd(Year, Month, Day)

tff(t_time, type, time: $tType).
tff(t_dt,   type, dt: ($int * $int * $int * $int * $int) > time). % Constructor: dt(Y, M, D, H, Min)

tff(t_dname, type, day_name: $tType). % Enumeration for Mon-Sun

% Day Name Constants
tff(dn_sun, type, sunday: day_name).
tff(dn_mon, type, monday: day_name).
tff(dn_tue, type, tuesday: day_name).
tff(dn_wed, type, wednesday: day_name).
tff(dn_thu, type, thursday: day_name).
tff(dn_fri, type, friday: day_name).
tff(dn_sat, type, saturday: day_name).

% --- Predicate Signatures ---
% is_days_in_month(Month, Year, Count) -> True if Month has Count days
tff(t_dim, type, is_days_in_month: ($int * $int * $int) > $o).

% calc_date(InputDays, InputMonth, InputYear, ResultDate) -> Logic for date math
tff(t_calc, type, calc_date: ($int * $int * $int * date) > $o).

% calc_datetime(Y,M,D,H,Min, AddD, AddH, AddMin, ResultTime) -> Wraps time & date logic
tff(t_calct, type, calc_datetime: ($int * $int * $int * $int * $int * $int * $int * $int * time) > $o).

% normalize_time(...) -> Handles minute/hour overflow and calculates extra days
tff(t_timeop, type, normalize_time: ($int * $int * $int * $int * $int * $int * $int) > $o).

% weekday(Date, DayName) -> True if Date falls on DayName
tff(t_wk,  type, weekday: (date * day_name) > $o).

% Internal helpers for Zeller's algorithm and scheduling
tff(t_zel, type, zeller_prep: ($int * $int * $int * $int * $int * $int) > $o). 
tff(t_map, type, map_iso: ($int * day_name) > $o).
tff(t_mapn, type, map_name_to_int: (day_name * $int) > $o).

% Scheduler: nth_weekday_date(N, DayName, Month, Year, ResultDate)
tff(t_sch, type, nth_weekday_date: ($int * day_name * $int * $int * date) > $o).
tff(t_sch_h, type, calc_nth_offset: ($int * $int * $int) > $o).

% --- The "Integer Trap" ---
% Crucial for Theorem Provers. Without this, Vampire will often return a symbolic 
% formula like "$difference(32, 1)" instead of "31". 
% Adding '& valid_day(D)' to a conjecture forces Vampire to solve the math 
% to prove the number is within the 1..31 range.
tff(t_trap, type, valid_day: ($int) > $o).
tff(trap_ax, axiom, ![D:$int]: (valid_day(D) <=> ($greater(D, 0) & $lesseq(D, 31)))).

% ==============================================================================
%  2. TIME ENGINE (Hours & Minutes)
% ==============================================================================

% Axiom: Time Normalization
% Purpose: Handles 65 minutes -> 1 hour 5 mins. Handles 25 hours -> 1 day 1 hour.
% Inputs: StartH, StartM, AddH, AddM.
% Outputs: EndH, EndM, DayDelta (extra days generated by time overflow).
tff(time_logic, axiom,
  ![SH:$int, SM:$int, AH:$int, AM:$int, EH:$int, EM:$int, DD:$int, TotalM:$int, NormM:$int, CarryH:$int, TotalH:$int]: (
    (
      TotalM = $sum(SM, AM) &                   % Sum Minutes
      NormM = $remainder_e(TotalM, 60) &        % Normalized Minutes (0-59)
      CarryH = $quotient_e(TotalM, 60) &        % Carry over Hours
      TotalH = $sum(SH, $sum(AH, CarryH)) &     % Sum Hours + Carry
      
      EH = $remainder_e(TotalH, 24) &           % Normalized Hours (0-23)
      EM = NormM &                              
      DD = $quotient_e(TotalH, 24)              % Day Delta (Hours / 24)
    ) => normalize_time(SH, SM, AH, AM, EH, EM, DD)
  )
).

% Axiom: Main DateTime Calculator
% Chains the Time Engine output (DayDelta) into the Date Engine.
tff(dt_logic, axiom,
  ![Y:$int, M:$int, D:$int, H:$int, Min:$int, AD:$int, AH:$int, AM:$int, ResY:$int, ResM:$int, ResD:$int, ResH:$int, ResMin:$int, TimeDayDelta:$int]: (
    (
      % 1. Calculate new Time and Extra Days
      normalize_time(H, Min, AH, AM, ResH, ResMin, TimeDayDelta) &
      % 2. Add original days + AddDays + TimeDayDelta using Date Engine
      calc_date($sum(D, $sum(AD, TimeDayDelta)), M, Y, ymd(ResY, ResM, ResD))
    ) => calc_datetime(Y, M, D, H, Min, AD, AH, AM, dt(ResY, ResM, ResD, ResH, ResMin))
  )
).

% ==============================================================================
%  3. DATE ENGINE (Relational)
% ==============================================================================

% Static Data: Days in standard months
tff(m1, axiom, ![Y:$int]: is_days_in_month(1, Y, 31)).
tff(m3, axiom, ![Y:$int]: is_days_in_month(3, Y, 31)).
tff(m4, axiom, ![Y:$int]: is_days_in_month(4, Y, 30)).
tff(m5, axiom, ![Y:$int]: is_days_in_month(5, Y, 31)).
tff(m6, axiom, ![Y:$int]: is_days_in_month(6, Y, 30)).
tff(m7, axiom, ![Y:$int]: is_days_in_month(7, Y, 31)).
tff(m8, axiom, ![Y:$int]: is_days_in_month(8, Y, 31)).
tff(m9, axiom, ![Y:$int]: is_days_in_month(9, Y, 30)).
tff(m10,axiom, ![Y:$int]: is_days_in_month(10, Y, 31)).
tff(m11,axiom, ![Y:$int]: is_days_in_month(11, Y, 30)).
tff(m12,axiom, ![Y:$int]: is_days_in_month(12, Y, 31)).

% Logic: Gregorian Leap Year Rules
% Rule: Year is leap if (Divisible by 4) AND (Not Divisible by 100 OR Divisible by 400)
tff(feb_leap, axiom, ![Y:$int]: ( ($remainder_e(Y, 4) = 0 & ($remainder_e(Y, 100) != 0 | $remainder_e(Y, 400) = 0)) => is_days_in_month(2, Y, 29))).
tff(feb_norm, axiom, ![Y:$int]: ( ($remainder_e(Y, 4) != 0 | ($remainder_e(Y, 100) = 0 & $remainder_e(Y, 400) != 0)) => is_days_in_month(2, Y, 28))).

% Logic: Recursive Date Calculation
% 1. Base Case: If Day fits in Month, we are done.
tff(rule_base, axiom, ![D:$int, M:$int, Y:$int, Limit:$int]: (( is_days_in_month(M, Y, Limit) & $greater(D, 0) & $lesseq(D, Limit) ) => calc_date(D, M, Y, ymd(Y, M, D)))).

% 2. Forward Overflow: If Day > MonthLimit, subtract Limit and move to Next Month.
%    Sub-case: If Month is 12, go to Month 1 of Next Year.
tff(rule_fwd,  axiom, ![D:$int, M:$int, Y:$int, Limit:$int, Res:date]: (( is_days_in_month(M, Y, Limit) & $greater(D, Limit) ) => ( (M=12 & calc_date($difference(D, Limit), 1, $sum(Y, 1), Res) => calc_date(D, M, Y, Res)) & (M!=12 & calc_date($difference(D, Limit), $sum(M, 1), Y, Res) => calc_date(D, M, Y, Res)) ))).

% 3. Backward Underflow: If Day <= 0, go to Previous Month and ADD its days.
%    Sub-case: If Month is 1, go to Month 12 of Previous Year.
tff(rule_back, axiom, ![D:$int, M:$int, Y:$int, Limit:$int, Res:date]: (( $lesseq(D, 0) ) => ( (M=1 & is_days_in_month(12, $difference(Y,1), Limit) & calc_date($sum(D, Limit), 12, $difference(Y, 1), Res) => calc_date(D, M, Y, Res)) & (M!=1 & is_days_in_month($difference(M,1), Y, Limit) & calc_date($sum(D, Limit), $difference(M, 1), Y, Res) => calc_date(D, M, Y, Res)) ))).

% ==============================================================================
%  4. SCHEDULER ENGINE
% ==============================================================================
% Logic to answer: "What date is the Nth [Weekday] of [Month] [Year]?"
% Example: "2nd Thursday of November 2025"

% Helper: Calculate gap between StartDay and TargetDay
% If Target >= Start: Gap = Target - Start
% If Target < Start:  Gap = 7 - (Start - Target)
tff(sch_offset_1, axiom, ![Start:$int, Target:$int]: ($lesseq(Start, Target) => calc_nth_offset(Start, Target, $difference(Target, Start)))).
tff(sch_offset_2, axiom, ![Start:$int, Target:$int]: ($greater(Start, Target) => calc_nth_offset(Start, Target, $difference(7, $difference(Start, Target))))).

% Mapping: Day Name to Integer (0-6, Saturday=0 to match Zeller)
tff(map_n_0, axiom, map_name_to_int(saturday, 0)).
tff(map_n_1, axiom, map_name_to_int(sunday, 1)).
tff(map_n_2, axiom, map_name_to_int(monday, 2)).
tff(map_n_3, axiom, map_name_to_int(tuesday, 3)).
tff(map_n_4, axiom, map_name_to_int(wednesday, 4)).
tff(map_n_5, axiom, map_name_to_int(thursday, 5)).
tff(map_n_6, axiom, map_name_to_int(friday, 6)).

% Main Scheduler Logic
tff(nth_weekday_logic, axiom,
  ![N:$int, DName:day_name, M:$int, Y:$int, StartDayName:day_name, StartDayInt:$int, TargetDayInt:$int, Offset:$int, FinalDay:$int]: (
    (
      % 1. Find the Weekday of the 1st of the month
      weekday(ymd(Y, M, 1), StartDayName) &
      map_name_to_int(StartDayName, StartDayInt) &
      
      % 2. Get Integer value of Target Day
      map_name_to_int(DName, TargetDayInt) &
      
      % 3. Calc Offset (Days to reach the first occurrence)
      calc_nth_offset(StartDayInt, TargetDayInt, Offset) &
      
      % 4. Formula: 1 + Offset + (N-1)*7
      FinalDay = $sum(1, $sum(Offset, $product($difference(N, 1), 7)))
    ) => nth_weekday_date(N, DName, M, Y, ymd(Y, M, FinalDay))
  )
).

% ==============================================================================
%  5. ZELLER'S CONGRUENCE (Universal Weekday Calculation); 
%.            1882/1883; The math always backs you up
% ==============================================================================
% Zeller's Congruence calculates the day of the week for ANY Gregorian date.
% Formula: h = (q + 13(m+1)/5 + K + K/4 + J/4 - 2J) mod 7

% Adjust Month/Year: Jan/Feb are counted as months 13/14 of the PREVIOUS year.
tff(zeller_adj_janfeb, axiom, ![M:$int, Y:$int]: ( (M = 1 | M = 2) => zeller_prep(M, Y, $sum(M, 12), $difference(Y, 1), $remainder_e($difference(Y, 1), 100), $quotient_e($difference(Y, 1), 100)))).
tff(zeller_adj_norm, axiom, ![M:$int, Y:$int]: ( (M != 1 & M != 2) => zeller_prep(M, Y, M, Y, $remainder_e(Y, 100), $quotient_e(Y, 100)))).

% The Main Formula
tff(calc_weekday_zeller, axiom,
  ![Y:$int, M:$int, D:$int, Name:day_name, ZM:$int, ZY:$int, K:$int, J:$int, H:$int, Term1:$int, Term2:$int]: (
    ( zeller_prep(M, Y, ZM, ZY, K, J) &
      Term1 = $quotient_e($product(13, $sum(ZM, 1)), 5) &
      Term2 = $sum(D, $sum(Term1, $sum(K, $sum($quotient_e(K, 4), $difference($quotient_e(J, 4), $product(2, J)))))) &
      H = $remainder_e($sum($remainder_e(Term2, 7), 7), 7) & % Handles negative mod results
      map_iso(H, Name)
    ) => weekday(ymd(Y, M, D), Name)
  )
).

% Output Mapping (0=Sat, 1=Sun, ... 6=Fri)
tff(map_0, axiom, map_iso(0, saturday)).
tff(map_1, axiom, map_iso(1, sunday)).
tff(map_2, axiom, map_iso(2, monday)).
tff(map_3, axiom, map_iso(3, tuesday)).
tff(map_4, axiom, map_iso(4, wednesday)).
tff(map_5, axiom, map_iso(5, thursday)).
tff(map_6, axiom, map_iso(6, friday)).

% ==============================================================================
%  6. ARITHMETIC HINTS (Ambiguity Prevention)
% ==============================================================================
% These axioms prevent Vampire from returning disjunctions (e.g., "Either Feb 28 or Feb 29")
% when it hasn't fully calculated the modulo for a specific year.

tff(hint_1900, axiom, ( ($remainder_e(1900, 4) = 0) & ($remainder_e(1900, 100) = 0) & ~($remainder_e(1900, 400) = 0) )).
tff(hint_2000, axiom, ( ($remainder_e(2000, 4) = 0) & ($remainder_e(2000, 100) = 0) & ($remainder_e(2000, 400) = 0) )).
tff(hint_2024, axiom, ($remainder_e(2024, 4) = 0)).
tff(hint_2025, axiom, ~($remainder_e(2025, 4) = 0)).

% ==============================================================================
%  7. CONJECTURE LIBRARY (30 TESTS)
% ==============================================================================

% -------------------------
% A. TIME & DATETIME
% -------------------------

% TEST 1: Time Overflow (Active)
% Scenario: Jan 1, 2025 23:00 + 2 hours -> Jan 2, 01:00.
%tff(test_time_overflow, conjecture,
%  ?[Y:$int, M:$int, D:$int, H:$int, Min:$int]: (
%    calc_datetime(2025, 1, 1, 23, 0, 0, 2, 0, dt(Y, M, D, H, Min)) &
%    valid_day(D)
%  )
%).

% TEST 2: Time Minute Rollover
% Scenario: 10:50 + 20 mins -> 11:10.
% tff(test_min_roll, conjecture,
%   ?[Y:$int, M:$int, D:$int, H:$int, Min:$int]: (
%     calc_datetime(2025, 1, 1, 10, 50, 0, 0, 20, dt(Y, M, D, H, Min)) & valid_day(D)
%   )
% ).

% TEST 3: Large Time Add
% Scenario: Add 49 hours (2 days + 1 hour).
% tff(test_large_time, conjecture,
%   ?[Y:$int, M:$int, D:$int, H:$int, Min:$int]: (
%     calc_datetime(2025, 1, 1, 12, 0, 0, 49, 0, dt(Y, M, D, H, Min)) & valid_day(D)
%   )
% ).

% TEST 4: New Year by Time
% Scenario: Dec 31, 2024 23:59 + 2 mins -> Jan 1, 2025 00:01.
% tff(test_new_year_time, conjecture,
%   ?[Y:$int, M:$int, D:$int, H:$int, Min:$int]: (
%     calc_datetime(2024, 12, 31, 23, 59, 0, 0, 2, dt(Y, M, D, H, Min)) & valid_day(D)
%   )
% ).

% -------------------------
% B. SCHEDULER (Nth Weekday)
% -------------------------

% TEST 5: "Second Thursday of Nov 2025"
% Logic: Nov 1 2025 is Sat. Thu is 6th. 2nd Thu is 13th.
% tff(test_nth_thursday, conjecture,
%   ?[Y:$int, M:$int, D:$int]: (
%     nth_weekday_date(2, thursday, 11, 2025, ymd(Y, M, D))
%   )
% ).

% TEST 6: "First Monday of Jan 2024"
% Jan 1 2024 = Monday. Result Jan 1.
% tff(test_first_monday, conjecture,
%   ?[Y:$int, M:$int, D:$int]: (
%     nth_weekday_date(1, monday, 1, 2024, ymd(Y, M, D))
%   )
% ).

% TEST 7: "4th Friday of Feb 2024"
% Feb 1 2024 = Thursday. 1st Fri = Feb 2. 4th = Feb 23.
% tff(test_4th_friday, conjecture,
%   ?[Y:$int, M:$int, D:$int]: (
%     nth_weekday_date(4, friday, 2, 2024, ymd(Y, M, D))
%   )
% ).

% -------------------------
% C. BASIC DATE ARITHMETIC
% -------------------------

% TEST 8: Simple Add (Jan 11)
% tff(test_simple_add, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, 10), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 9: Month Roll (Feb 4)
% tff(test_month_roll, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(30, 5), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 10: Large Add (May 14)
% tff(test_large_add, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(15, 120), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 11: Simple Sub (Jan 5)
% tff(test_simple_sub, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(10, -5), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 12: Back Leap (Feb 28)
% tff(test_back_leap, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, -2), 3, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 13: Year Back (Dec 31)
% tff(test_year_back, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, -1), 1, 2025, ymd(Y, M, D)) & valid_day(D))).

% -------------------------
% D. LEAP YEAR CHECKS
% -------------------------

% TEST 14: Leap Exists (Feb 29)
% tff(test_leap_ok, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(25, 4), 2, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 15: Leap Not Exists (Mar 1)
% tff(test_leap_no, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(25, 4), 2, 2025, ymd(Y, M, D)) & valid_day(D))).

% TEST 16: 1900 Rule (Mar 1)
% tff(test_1900, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(28, 1), 2, 1900, ymd(Y, M, D)) & valid_day(D))).

% TEST 17: 2000 Rule (Feb 29)
% tff(test_2000, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(28, 1), 2, 2000, ymd(Y, M, D)) & valid_day(D))).

% -------------------------
% E. INTEGRATED LOGIC
% -------------------------

% TEST 18: Add week + Name
% tff(test_add_week, conjecture, ?[Y:$int, M:$int, D:$int, N:day_name]: (calc_date($sum(12, 7), 11, 2025, ymd(Y, M, D)) & weekday(ymd(Y, M, D), N) & valid_day(D))).

% TEST 19: Next Year Same Day
% tff(test_next_year, conjecture, ?[Y:$int, M:$int, D:$int, N:day_name]: (calc_date($sum(19, 365), 11, 2025, ymd(Y, M, D)) & weekday(ymd(Y, M, D), N) & valid_day(D))).

% -------------------------
% F. YEAR BOUNDARIES
% -------------------------

% TEST 20: New Year Forward
% tff(test_ny_fwd, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(31, 1), 12, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 21: Big Jump
% tff(test_big_jump, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(2, 400), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 22: Two Year Jump
% tff(test_2yr_jump, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, 731), 1, 2024, ymd(Y, M, D)) & valid_day(D))).

% -------------------------
% G. HISTORICAL
% -------------------------

% TEST 23: 1776 (Thu)
% tff(test_1776, conjecture, ?[N:day_name]: weekday(ymd(1776, 7, 4), N)).

% TEST 24: Moon Landing (Sun)
% tff(test_moon, conjecture, ?[N:day_name]: weekday(ymd(1969, 7, 20), N)).

% TEST 25: BTTF (Sat)
% tff(test_bttf, conjecture, ?[N:day_name]: weekday(ymd(1985, 10, 26), N)).

% TEST 26: 1600 Epoch (Sat)
% tff(test_1600, conjecture, ?[N:day_name]: weekday(ymd(1600, 1, 1), N)).

% -------------------------
% H. MISC EDGE CASES
% -------------------------

% TEST 27: Dec Boundary Calc
% tff(test_dec_bound, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, 30), 12, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 28: Zero Day
% tff(test_zero, conjecture, ?[Y:$int, M:$int, D:$int]: (calc_date($sum(1, -1), 3, 2024, ymd(Y, M, D)) & valid_day(D))).

% TEST 29: Future Weekday
% tff(test_2030, conjecture, ?[N:day_name]: weekday(ymd(2030, 1, 1), N)).

% TEST 30: Leap Weekday
% tff(test_leap_wk, conjecture, ?[N:day_name]: weekday(ymd(2024, 2, 29), N)).