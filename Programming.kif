;; Programming.kif
;; Define SUMO classes and rules for Programming Languages and their shared patterns

;; Basic programming language taxonomy
(subclass ProgrammingLanguage ComputerLanguage)
(termFormat EnglishLanguage ProgrammingLanguage "programming language")
(documentation ProgrammingLanguage EnglishLanguage "A programming language is a computer language meant to dictate the execution of a computer processor according to a deterministic procedure. ComputerPrograms are implemented using ProgrammingLanguages")

;; Classify programming languages by "paradigm"
(subclass ProgrammingParadigm Attribute)
(termFormat EnglishLanguage ProgrammingParadigm "programming language paradigm")
(documentation ProgrammingParadigm EnglishLanguage "A programming language's paradigm is the overall methodology used to implement a computer program. Programming languages often are implemented to support one or many paradigms, where programming languages which use a single paradigm (e.g. Haskell) are considered stricter and more single purpose than languages which support multiple paradigms (e.g. Python)")

(subclass ObjectOrientedProgramming ProgrammingParadigm)
(termFormat EnglishLanguage ObjectOrientedProgramming "object oriented programming")
(documentation ObjectOrientedProgramming EnglishLanguage "Object oriented programming languages are programming languages which utilize the concept of treating programs as manipulations of objects, where objects have attributes (properties) and can take actions (methods). Object oriented languages define object prototypes (often called classes) and instatiate those classes during the course of program execution. Certain object oriented languages enforce these patterns more strictly than others (e.g. Java vs Python).")

(subclass FunctionalProgramming ProgrammingParadigm)
(termFormat EnglishLanguage FunctionalProgramming "functional programming")
(documentation FunctionalProgramming EnglishLanguage "Functional programming languages utilize functions in the mathematic sense: they strictly map inputs to outputs such that each invocation of a function produces the same output whenever passes the same inputs (arguments). Often, functional programming languages lack a global scope other than the scope which contains the mapping of functional names to function executions. Certain languages enforce this functional paradigm more strictly than others.")

(subclass DeclarativeProgramming ProgrammingParadigm)
(termFormat EnglishLanguage DeclarativeProgramming "declarative programming")
(documentation DeclarativeProgramming EnglishLanguage "Declarative programming is the paradigm by which programs are defined by their outcome and not their implementation. For example, delcarative languages will describe \"summary all grades in the class\" but not specify details such as how the grades are represented (whole number or fractional), how they are retrieved, or what the mathematical method by which to summarize those grades. All these operations are typically baked into the program which interprets and executes the written code.")

(subclass ImperativeProgramming ProgrammingParadigm)
(termFormat EnglishLanguage ImperativeProgramming "imperative programming")
(documentation ImperativeProgramming EnglishLanguage "Counter to declarative programming, imperative programming focuses on the step-by-step procedure of directing a computer program's execution. It is, therefore, the job of the programmer to understand the desired outcome and how direct the computer the steps to reach it.")

(subclass ProgrammingLanguageAbstraction Attribute)
(termFormat EnglishLanguage ProgrammingLanguageAbstraction "programming language abstraction")
(documentation ProgrammingLanguageAbstraction EnglishLanguage "The abstraction of a programming language refers to how closely the language maps to the actual operations being taken by the physical processor of a computer system. This can range from directly mapping to the binary switching of the transistors that make up the computational elements of a processor, to near natural language which is processed through multiple layers of conversion to reach a state executable by a physical computer system. Programming languages with lower levels of abstraction are typically more difficult to write, but provide the coder with more minute control over the computer to control for things like execution efficiency and cross-platform behavior.")

;; Programming language abstraction
(subclass AssemblyLanguage ProgrammingLanguageAbstraction)
(termFormat EnglishLanguage AssemblyLanguage "assembly language")
(documentation AssemblyLanguage EnglishLanguage "Assembly languages are the lowest abstracted type of programming language and either are directly implemented using binary code, or using human language mnemonics which have a one-to-one mapping to binary strings.")

(subclass LowLevelLanguage ProgrammingLanguageAbstraction)
(termFormat EnglishLanguage LowLevelLanguage "low level language")
(documentation AssemblyLanguage EnglishLanguage "Low level languages do not directly map to the binary utilized by physical processors, but they do allow for full control over the manipulation of physical devices such as computer memory, arithmetic operations, and processor signalling with little additional functionality provided by the language itself")

(subclass HighLevelLanguage ProgrammingLanguageAbstraction)
(termFormat EnglishLanguage HighLevelLanguage "high level language")
(documentation HighLevelLanguage EnglishLanguage "High level languages represent languages which do not allow programs written in said language easy (or any) access to the underlying physical operation of a computer system via restrictions to the language. For example, it is common for higher order languages to wrap primitives such as strings and arrays in a data structure more complex then sequential bytes in memory.")

;; They are disjoint (a language cannot be both high and low level)
(disjoint HighLevelLanguage LowLevelLanguage)
(disjoint HighLevelLanguage AssemblyLanguage)
(disjoint LowLevelLanguage AssemblyLanguage)

;; Finally, a language can be compiled and/or interpretted
(subclass ProgrammingLanguageExecution Attribute)
(termFormat EnglishLanguage ProgrammingLanguageExecution "programming language execution methodoloy")
(documentation ProgrammingLanguageExecution EnglishLanguage "The execution methodology of a programming language is the means by which a program written in a given language is executed by a computer system. It is completely reasonable for a language to be able to be executed by multiple means, while other languages are strictly limited to one execution methodology.")

(subclass InterprettedLanguage ProgrammingLanguageExecution)
(termFormat EnglishLanguage InterprettedLanguage "interpretted language")
(documentation InterprettedLanguage EnglishLanguage "Interpretation, in the context of computer programming, refers to programs written in languages which are transformed to a form understandable by a computer system at the time of execution and are distributed as their source code (or some formatted variant of their source code) for execution on other systems.")

(subclass CompiledLanguage ProgrammingLanguageExecution)
(termFormat EnglishLanguage CompiledLanguage "compiled language")
(documentation CompiledLanguage EnglishLanguage "Compiled programming languages are those programming languages which must be transformed into some machine understable language as a whole, prior to execution either directly by a processor, or a dedicated runtime environment. Programs written in compiled languages are distributed in their transformed state, and often must undergo compilation to include compatibility with the environment in which they are being deployed (e.g. cross-compilation is the idea of compiling a program to work on multiple computer system technologies such as computer architecture, operating system, or virtual machine version).")

;; Now given some examples of programming languages
(instance C ProgrammingLanguage)
(termFormat EnglishLanguage C "C")
(attribute C LowLevelLanguage)
(attribute C FunctionalProgramming)
(attribute C ImperativeProgramming)
(attribute C CompiledLanguage)
(documentation C EnglishLanguage "C is a general purpose, low level, compiled programming language. Originally developed in the 1970s at Bell Labs, Dennis Ritchie is generally creditted as its creator. Despite its age, C is widely used today for systems which require hardware level operation and need strict performance control due to low computational capability.")

(instance CPlusPlus ProgrammingLanguage)
(termFormat EnglishLanguage CPlusPlus "C++")
(attribute CPlusPlus HighLevelLanguage)
(attribute CPlusPlus FunctionalProgramming)
(attribute CPlusPlus ImperativeProgramming)
(attribute CPlusPlus ObjectOrientedProgramming)
(attribute CPlusPlus CompiledLanguage)
(documentation CPlusPlus EnglishLanguage "C++ (pronounced: \"C Plus Plus\") is a general purpose, high level, compiled, object oriented programming language. Its name derives from the fact that it was originally released in the 1980s as an extension to the C programming language to intrdouce object oriented programming concepts. Of the high level languages, C++ still exposes many of the low level interfaces available in C, which is why C++ is favored as both an easy-to-implement, performant language.")

(instance Python ProgrammingLanguage)
(termFormat EnglishLanguage Python "python")
(attribute Python HighLevelLanguage)
(attribute Python InterprettedLanguage)
(attribute Python ObjectOrientedProgramming)
(attribute Python ImperativeProgramming)
(attribute Python FunctionalProgramming)
(documentation Python EnglishLanguage "Python is a general purpose, high level, interpretted programming language. It is named after the British comedy troupe Monty Python as it was intended to be as fun to program as their comedy was to watch. Python's syntax is considered simple for its readability and is unique as it requires certain whitespace formatting, compared to other languages, which generally ignore whitespace in its syntax. Python is flexible, allowing for most programming paradigms. Since its creation, Python, as a language, has received two breaking changes which makes later code incompatible with earlier python interpretter versions.")

(instance Java ProgrammingLanguage)
(termFormat EnglishLanguage Java "java")
(attribute Java HighLevelLanguage)
(attribute Java InterprettedLanguage)
(attribute Java CompiledLanguage)
(attribute Java ObjectOrientedProgramming)
(attribute Java ImperativeProgramming)
(documentation Java EnglishLanguage "Java is a strictly object oriented, general purpose, programming language. Released in 1995 by Sun Microsystems, it was one of the first widely used \"write once, run anywhere\" languages, meaning that Java code could be compiled or interpretted on any machine that had the Java Virtual Machine (JVM). Being strictly object oriented, all code must be contained within a class, while classes are organized into a hierarchy called packages.")

;; Expand the defition of computer programs to make them collections of executable expressions
(subrelation computerProgramDefinition TernaryPredicate)
(domain computerProgramDefinition 1 ComputerProgram)
(domain computerProgramDefinition 2 ProgrammingLanguage)
(domain computerProgramDefinition 3 ProgramExpression)
(documentation computerProgramDefinition EnglishLanguage "A relation definition how a computer program is implemented in a given language. A computer program is often implemented in different languages. The most common case of this occurrence is the implementation of a computer program in a higher order language, which is then converted to a lower order language via processes such as compilation or intepretation")

;; General subclass of Linguistic Expressions to cover those specifically for programming
(subclass ProgrammingStatement LinguisticExpression)
(documentation ProgrammingStatement EnglishLanguage "All linguistic expressions which comprise valid programming language syntax")

;; Core executable unit of a program is an expression
(subclass ProgramExpression ProgrammingStatement)
(termFormat EnglishLanguage ProgramExpression "computer expression")
(documentation ProgramExpression EnglishLanguage "A single unit of executable code")

;; Define a class for a errors occuring during the execution of a program
(subclass ProgramFault ProgrammingStatement)
(termFormat EnglishLanguage ProgramFault "computer error")
(documentation ProgramFault EnglishLanguage "An error caused by a computer program failing to execute")
(instance FaultFn UnaryFunction)
(domain FaultFn 1 SymbolicString)
(range FaultFn ProgramFault)
(documentation FaultFn EnglishLanguage "Create a new fault")
(=>
    (eq ?FAULT (FaultFn ?ERR))
    (names ?ERR ?FAULT))

;; Core unary relation indicating that an executable expression was, indeed, executed during the runtime of a program
(instance executed UnaryPredicate)
(domain executed 1 ProgramExpression)
(documentation executed EnglishLanguage "Indicates that a singular executable unit of a program has been executed")
;; Counter to executed, which assumes that execution was successful, the fault relation, indicates that a given expression failed to execute with a specific error
(instance fault BinaryPredicate)
(domain fault 1 ProgramExpression)
(domain fault 2 ProgramFault)
(documentation fault EnglishLanguage "Indicates that in the course of the execution of an expression, it caused a specific error")

;; Definitions are declarative statements in a computer program which assign executable code and various metadata to a symbol in the context of a running program
(subclass ProgramDefinition ProgrammingStatement)
(documentation ProgramDefinition EnglishLanguage "Definitions are declarative statements in a computer program which assign executable code and various metadata to a symbol in the context of a running program")

;; Define the concept of scope, which is essentially a contextual symbol table
(instance ProgramScope ContentBearingPhysical)
(documentation ProgramScope EnglishLanguage "A contextualization of a symbol table, where subsumed \"lower\" scopes ovewrite the mappings of symbols to values established in \"higher\" scopes")
(termFormat EnglishLanguage ProgramScope "Program scope")

; Get the resultant value of an expression
(instance ExpressionValueFn UnaryFunction)
(domain ExpressionValueFn 1 ProgramExpression)
(range ExpressionValueFn Entity)
(termFormat EnglishLanguage ExpressionValueFn "expression value")
(format EnglishLanguage ExpressionValueFn "the value of the expression, %1")

(instance scope BinaryPredicate)
(domain scope 1 ProgramScope)
(domain scope 2 ProgrammingStatement)
(documentation scope EnglishLanguage "A relation which indicates that a given expression belongs to a given scope. An expression can only belong to a single scope")
(termFormat EnglishLanguage scope "scope")
(format EnglishLanguage scope "%1 has a scope of %2")
; An expression can only belong to a single scope
(=>
    (and
        (scope ?SCOPE ?EXP)
        (instance ?OTHERSCOPE)
        (not (equal ?EXP ?OTHERSCOPE)))
    (not (scope ?OTHERSCOPE ?EXP)))

; Next handle expression parents and how that determines scope
(instance parentExpression BinaryPredicate)
(domain parentExpression 1 ProgramExpression)
(domain parentExpression 2 ProgramExpression)
(termFormat EnglishLanguage parentExpression "parent expressionm")
(documentation parentExpression EnglishLanguage "In a program, often one expression contains another. This predicate captures that relationship between expressions")
;; An expression can only have a single parent
(=>
    (and 
        (parentExpression ?P ?EXP)
        (instance ?OTHER ProgramExpression)
        (not (equal ?P ?OTHER)))
    (not (parentExpression ?OTHER ?EXP)))
; If there exists no symbol in a child's scope, BUT there is a symbol in the parent scope 
;; IM STUCK HERE!!

(instance pointsTo TernaryPredicate)
(domain pointsTo ProgramScope)
(domain pointsTo SymbolicString)
(domain pointsTo Entity)
(termFormat EnglishLanguage pointsTo "points to")
(documentation pointsTo EnglishLanguage "(pointsTo ?SCOPE ?SYM ?VAL) means that, in some program scope ?SCOPE, the symbol ?SYM, maps to the value ?VAL")

; Assignment expression encapusulates a VariableDefinition
(instance AssignmentExpressionFn UnaryFunction)
(domain AssignmentExpressionFn 1 VariableTypeDeclaration)
(domain AssignmentExpressionFn 2 SymbolicString)
(domain AssignmentExpressionFn 3 Expression)
(range AssignmentExpressionFn ProgramExpression)
(termFormat EnglishLanguage AssignmentExpressionFn "assignment expression")
(format Python AssignmentExpressionFn "%2 = %3")
(format English AssignmentExpressionFn "The symbol %2 has a value of %3 with a type of %1")
(documentation AssignmentExpressionFn EnglishLanguage "An assignment expression establishes that a given symbol has a specific value with a given type")
; Execute the right hand expression to get the resultant value when you execute the assignment
(=>
    (executed (AssignmentExpressionFn ?TYPE ?SYM ?EXP))
    (executed ?EXP))
; Error out if the variable types dont match
(=>
    (and
        (equal ?ASS (AssignmentExpressionFn ?TYPE ?SYM ?EXP))
        (executed ?ASS)
        (not (exists (?F) (fault ?EXP ?F)))
        (equal ?VAL (ExpressionValueFn ?EXP))
        (instance ?VAL ?VALTYP)
        (not (equal ?VALTYP ?TYPE)))
    (fault ?ASS (FaultFn "type mismatch")))
; Propogate faults upwards
(=>
    (and 
        (equal ?ASS (AssignmentExpressionFn ?TYPE ?SYM ?EXP))
        (executed ?ASS)
        (fault ?EXP ?F))
    (fault ?ASS ?F))
; When running assignment, if the right hand expression does not fail, then get the value from the righthand expression and assign it to the symbol
(=>
    (and
        (equal ?ASS (AssignmentExpressionFn ?TYPE ?SYM ?EXP))
        (executed ?ASS)
        (not (exists (?F) (fault ?EXP ?F)))
        (scope ?SCOPE ?ASS))
        (equal ?VAL (ExpressionValueFn ?EXP))
    (and
        (pointsTo ?SCOPE ?SYM ?VAL)))
; In most programming languages, the value of this expression is the value of the right hand expression (TODO: figure out a way to change behavior based on language)
(=>
    (equal ?VAL (ExpressionValueFn (AssignmentExpressionFn ?TYPE ?SYM ?EXP)))
    (equal ?VAL (ExpressionValueFn ?EXP)))

;; A simple sequential code execution, where each child expression executes sequentially, so long as the line previous did not fault
(instance BlockExpressionFn Function)
(instance BlockExpressionFn VariableArityRelation)
(domain BlockExpressionFn 1 Expression)
(range BlockExpressionFn ProgramExpression)
(documentation BlockExpressionFn EnglishLanguage "A block expression is an expression which sequentially executes one expression after another so long as the previous expression did not fault")
(termFormat EnglishLanguage BlockExpressionFn "block expression")
(termFormat C BlockExpressionFn "({\n\t%*[;\n\t]\n})")
(termFormat CPlusPlus BlockExpressionFn "({\n%*[;\n\t]\n})")
(termFormat Java BlockExpressionFn "({\n%*[;\n\t]\n})")
(termFormat Python BlockExpressionFn "(%*[\n\t])")
(=>
    (equal ?BLOCK (BlockExpressionFn @ROW))
    (equal ?EXPRESSIONS (ListFn @ROW))
    (=>
        (and
            (equal ?EXP1 (ListOrderFn ?EXPRESSIONS ?NUM1))
            (equal ?EXP2 (ListOrderFn ?EXPRESSIONS ?NUM2))
            (equal ?NUM1 (AdditionFn ?NUM2 1))
            (executed ?EXP1)
            (not (fault ?EXP1 ?F)))
        (executed ?EXP2)))
;; When you execute a block expression, the first expression is executed
(=>
    (executed (BlockExpressionFn @ROW))
    (executed (FirstFn (ListFn @ROW))))
;; Establish the parent expression relationship
(=>
    (and
        (equal ?B (BlockExpressionFn @ROW))
        (inList (ListFn @ROW) ?EXP))
    (parentExpression ?B ?EXP)) 
; In most programming languages, the value of this expression is void
;; NOT SURE HOW TO REPRESENT VOID
(not (exists (?VAL) (equal ?VAL (ExpressionValueFn (BlockExpressionFn @EXPS)))))

;; A simple conditional expression
(instance ConditionalExpressionFn TernaryFunction)
(domain ConditionalExpressionFn 1 TrueValue)
(domain ConditionalExpressionFn 2 ProgrammingLanguageExpression)
(domain ConditionalExpressionFn 3 ProgrammingLanguageExpression)
(range ConditionalExpressionFn ProgrammingLanguageExpression)
(documentation ConditionalExpressionFn EnglishLanguage "In the context of programming, a conditional expression is an expression which contains one truth statement to evaluate and two executable code paths. If the statement evaluates to true, one branch of execution is taken, whereas if the statement evaluates to false, the other path is executed. There is no case in which both paths can be executed during a single evaluation of the expression")
(format EnglishLanguage ConditionalExpressionFn "If %1 is True, then %2, else %3")
(termFormat EnglishLanguage ConditionalExpressionFn "conditional expression")
;; If the statement evaluates to true, the truth branch is executed within the context of the parent expression and the false branch is not executed
(=>
    (and ?E
        (equal ?CE (ConditionalExpressionFn ?E ?T ?F))
        (executes ?CE))
    (and
        (parentExpression ?CE ?T)
        (executes ?T)
        (not (executes ?F))))
;; If the statement evaluates to false, the truth branch is executed within the context of the parent expression and the true branch is not executed
(=>
    (and (not ?E)
        (equal ?CE (ConditionalExpressionFn ?E ?T ?F))
        (executes ?CE))
    (and
        (parentExpression ?CE ?F)
        (executes ?F)
        (not (executes ?T))))
;; Propogate the faults upwards
(=>
    (and 
        (equal ?CE (ConditionalExpressionFn ?E ?T ?F))
        (executes ?CE)
        (executes ?T)
        (fault ?T ?FAULT))
    (fault ?CE ?FAULT))
(=>
    (and 
        (equal ?CE (ConditionalExpressionFn ?E ?T ?F))
        (executes ?CE)
        (executes ?F)
        (fault ?F ?FAULT))
    (fault ?CE ?FAULT))
; In most programming languages, the value of this expression is void
;; NOT SURE HOW TO REPRESENT VOID
(not (exists (?VAL) (equal ?VAL (ExpressionValueFn (ConditionalExpressionFn ?V ?T ?F)))))

;; Functions
;; A type of program definition with defines a function
(subclass FunctionDefinition ProgramDefinition)
(documentation FunctionDefinition EnglishLanguage "A function, in the context of computer programming, is a reusable section of executable code which whose behavior can be influenced by the scope which is inherits as well as the inputs it receives in the form of arguments. Functions may or may not produce a resultant value (referred to as a return value). Functions are a mapped relation between inheritted scope and resultant execution, but may not be a consistent mapped relation between its arguments and return value as it could maintain an internal state and/or receive indirectly declared inputs from its parent scope at the time of invocation. A function definition is different from its invocation as, at the time of its invocation, its code block is not actually executed. Some languages evaluate the validity of a function's code at the time of declaration, which others trust function;s implementations and misimplemented functions result in runtime errors.")

;; Helper relations to define a function's properties
;; Define the arguments for a function definition
(subrelation numArguments attribute)
(domain numArguments 1 FunctionDefinition)
(domain numArguments 2 PositiveInteger)
(documentation numArguments EnglishLanguage "The number of arguments that a function takes")
;; Define the actual arguments now
(instance functionArgument QuaternaryPredicate)
(domain functionArgument 1 FunctionDefinition)
(domain functionArgument 2 PositiveInteger)
(domain functionArgument 3 SymbolicString)
(domain functionArgument 4 VariableTypeDefinition)
(documentation functionArgument EnglishLanguage "Provides a means of defining the inputs to a function definition in the context of a computer program. The formula (functionArgument ?F ?P ?S ?T) means that the function ?F has an argument at position ?P will be injected into the scope as a variable with the symbol ?S and the value introduced at the time of the invocation of the function, which must be an instance of the VariableTypeDefinition ?T")
;; Define the expression that the function actually executes
(subrelation functionExpression attribute)
(domain functionExpression 1 FunctionDefinition)
(domain functionExpression 2 ProgramExpression)
(documentation functionExpression EnglishLanguage "The body of a defined function is the expression executed with the injected scope when a function is invoked at runtime")
(format EnglishLanguage functionExpression "When invoked the function %1 will execute the expression: %2")
;; Define the concept of return type of a program function
(subrelation functionReturn attribute)
(domain functionReturn 1 FunctionDefinition)
(domain functionReturn 2 VariableTypeDefinition)
(documentation functionReturn EnglishLanguage "The type of value returned as a resultant of a function. The type VoidType indicates that a function does not emit a resultant value directly.")
;; The actual invocation of a function
(subclass FunctionCallFn Function)
(subclass FunctionCallFn VariableArityRelation)
(domain FunctionCallFn 1 FunctionDefinition)
(domain FunctionCallFn 2 Expression)
(range FunctionCallFn ProgramExpression)
(documentation FunctionCallFn EnglishLanguage "The actual invocation of a FunctionDefinition. To invoke a function, the program must specify which previously defined function to execute as well as map the arguments expected by the invoked function to values of the appropriate types. The lis tof values are injected into the ProgramScope of a the functionBody of the FunctionDefinition")
;; Additional classes and functions used later on the dictate the invokation of functions
(subclass ParameterizeFn TernaryFunction)
(domain ParameterizeFn 1 FunctionDefinition)
(domain ParameterizeFn 2 ProgramScope)
(domain ParameterizeFn 3 List)
(range ParameterizeFn ProgramScope)
(documentation ParameterizeFn EnglishLanguage "A function which maps a value list passed to the invocation of a function to the defition of that function to produce a scope to be injected into the context of the execution of that function's body")
(=>
    (and
        (ParameterizeFn ?FUNC ?SCOPE ?ARGS)
        (numArguments ?FUNC ?NUMARGS)
        (lessThan (ListLengthFn ?ARGS) ?NUMARGS))
    (=> 
        (equal ?A (ListOrderFn ?ARGS ?NUM))
        ()))

;; Rules which govern the execution of a function
;; When yoiu execute a function, execute its arguments one-by-one
(=>
    (and
        (equal ?FC (FunctionCallFn ?F @ARGS))
        (executes ?FC))
    (and
        (executes (BlockExpressionFn @ARGS))
        (parentExpression ?FC (BlockExpressionFn @ARGS))))
;; Propogate faults fro executing its arguments
(=>
    (and
        (equal ?FC (FunctionCallFn ?F @ARGS))
        (executes ?FC)
        (executes (BlockExpressionFn @ARGS))
        (faults (BlockExpressionFn @ARGS) ?F))
    (faults (BlockExpressionFn @ARGS) ?F))
;; If youve executed the function and all its arguments are without fault, the body executes within the context of the function call
(=>
    (and 
        (equal ?FC (FunctionCallFn ?F @ARGS))
        (equal ?AL (ListFn @ARGS))
        (executes ?FC)
        (functionBody ?F ?BE)
        (scope ?BODYSCOPE ?BE))
        (not (exists (?F) (fault (BlockExpressionFn @ARGS) ?F)))
    (and
        (parentExpression ?FC ?B)
        (executes ?B))
        ; inject the arguments into the scope based on the argument name
        (=>
            (and
                (equal ?EXP (ListOrderFn ?AL ?INDX))
                (functionArgument ?F ?SYM ?INDX ?TYPE))
            (and
                (executes ?EXP)
                (=>
                    (not (exists (?F) (fault ?EXP ?F))) 
                    (pointsTo ?BODYSCOPE ?SYM (ExpressionValueFn ?EXP))))))
;; propogate faults
(=>
    (and
        (equal ?FC (FunctionCallGn ?F @ARGS))
        (functionBody ?F ?BODY)
        (executed ?BODY)
        (faults ?BODY ?F))
    (faults ?FC ?F))
;; The number of arguments defined for a function must equal the number of values provided to a the function when it is invoked
(=> 
    (and
        (executes (FunctionCallFn ?F @ARGS))
        (numArguments ?F ?N))
    (equal (ListLengthFn (ListFn @ARGS)) ?N))
;; When a function is invoked, the types of the variables in the ValueList passed as its arguments, must adhere to the types of vales defined for its arguments at the position corrsponding to the position of the value in the ValueList
(=>
    (and
        (executes (FunctionCallFn ?F @ARGS))
        (functionArgument ?F ?N ?S ?T)
        (equal (ListOrderFn (ListFn @ARGS) ?N) ?V))
    (instance ?V ?T))
;; The value of a function call is the return value
;; Establish "return" as a type of expression
(instance ReturnExpressionFn UnaryFunction)
(domain ReturnExpressionFn 1 ProgramExpression)
(range ReturnExpressionFn ProgramExpression)
(format Python ReturnExpressionFn "return %1")
(format C ReturnExpressionFn "return %1;")
(format EnglishLanguage ReturnExpressionFn "the function returns %1")
(termFormat EnglishLanguage ReturnExpressionFn "return expression")
(documentation ReturnExpressionFn EnglishLanguage "The return expression is used to indicate the resultant value of the function call expression which invokes the function in which it is contained")
(eq (ExpressionValueFn (ReturnExpressionFn ?EXP)) (ExpressionValueFn ?EXP))

(instance ancestorExpression BinaryPredicate)
(domain 1 ancestorExpression ProgramExpression)
(domain 2 ancestorExpression ProgramExpression)
(termFormat EnglishLanguage ancestorExpression "ancestor expression")
(format EnglishLanguage ancestorExpression "the expression %1 is an ancestor to %2")
(documentation ancestorExpression EnglishLanguage "All expressions that are the parent to an expression are the ancestor to that expression and all expression for which its child is an ancestor")
(=>
    (parentExpression ?EXP1 ?EXP2)
    (and
        (ancestorExpression ?EXP1 ?EXP2)
        (=>
            (ancestorExpression ?EXP2 ?EXP3)
            (ancestorExpression ?EXP1 ?EXP3))))

;; Next we try to determine the value of a function call expression based on the value of the executed return expression inside of the function body
(=>
    (and
        (executes (FunctionCallFn ?F @ARGS))
        (functionBody ?F ?BODY)
        (executes ?BODY)
        (ancestor ?BODY (ReturnExpressionFn ?EXP))
        (executes (ReturnExpressionFn ?EXP)))
    (equal (ExpressionValueFn ?EXP) (ExpressionValueFn (FunctionCallFn ?F @ARGS))))

;; Now literal expressions
(instance LiteralStringExpressionFn UnaryFunction)
(domain LiteralStringExpressionFn 1 SymbolicString)
(range LiteralStringExpressionFn ProgramExpression)
(documentation LiteralStringExpressionFn EnglishLanguage "A literal string expression is some string of letters passed into the program by the writer of the program")
(format Python LiteralStringExpressionFn "\"%1\"")
(format C LiteralStringExpressionFn "\"%1\"")
(equal (ExpressionValueFn (LiteralStringExpressionFn ?SYM)) ?SYM)

(instance NumericLiteralExpressionFn BinaryFunction)
(domain NumericLiteralExpressionFn 1 Number)
(domain NumericLiteralExpressionFn 2 Class)
(range NumericLiteralExpressionFn ProgramExpression)
(documentation NumericLiteralExpressionFn EnglishLanguage "A numerical expression is some number passed into the program by the writer of the program. The type of number should be passed as the second argument")
(=>
    (NumericLiteralExpressionFn ?NUM ?TYP)
    (and
        (subclass ?TYP Number)
        (instance ?NUM ?TYP)))
(equal (ExpressionValueFn (NumericLiteralExpressionFn ?NUM ?TYP)) ?NUM)
(instance (ExpressionValueFn (NumericLiteralExpressionFn ?NUM ?TYP)) ?TYP)

(instance BinaryNumericOperationFn TernaryFunction)
(domain BinaryNumericOperationFn 1 BinaryFunction)
(domain BinaryNumericOperationFn 2 ProgramExpression)
(domain BinaryNumericOperationFn 3 ProgramExpression)
(range BinaryNumericOperationFn ProgramExpression)
(documentation BinaryNumericOperationFn EnglishLanguage "This function maps a SUMO numeric function to a program expression. When executed, it will execute the two subexpressions. If their value is not a number AND do not match (i.e. Integer with Real Number) this will fault. This should NOT be used for boolean operations (lessThan, greaterThan, etc)")
(=>
    (and
        (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT)
        (range ?FUNC ?CLASS))
    (subclass ?CLASS RealNumber))
(=>
    (executed (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT))
    (and 
        (executed (BlockExpressionFn ?LEFT ?RIGHT))
        (parentExpression (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT) (BlockExpressionFn ?LEFT ?RIGHT))))
(=>
    (and
        (executed (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT))
        (fault ?LEFT ?F))
    (fault (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT) ?F))
(=>
    (and
        (executed (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT))
        (fault ?RIGHT ?F))
    (fault (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT) ?F))'
(=>
    (and
        (executed (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT))
        (not (or 
            (instance (ExpressionValueFn ?LEFT) RealNumber)
            (instance (ExpressionValueFn ?RIGHT) RealNumber))))
    (fault (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT) (FaultFn "numeric operation performed against non-numeric arguments")))
(=>
    (and
        (equal ?OP (BinaryNumericOperationFn ?FUNC ?LEFT ?RIGHT))
        (executed ?OP)
        (not (exists (?F) (fault ?OP ?F))))
        (equal ?NUM1 (ExpressionValueFn ?LEFT))
        (equal ?NUM2 (ExpressionValueFn ?RIGHT))
    (equal (ExpressionValueFn ?OP) (?FUNC ?NUM1 ?NUM2)))
    

(instance VariableExpressionFn BinaryFunction)
(instance VariableExpressionFn 1 SymbolicString)
(instance VariableExpressionFn 2 Class)
(range VariableExpressionFn ProgramExpression)
(documentation VariableExpressionFn EnglishLanguage "This expression will replace a variable with its value within the scope of the current expression. In the case that the symbol has not been either declared or instantiated in the current scope, this expression faults. Similarly ")
(format Python VariableExpressionFn "%1")
(format C VariableExpressionFn "%1")
(=> 
    (and 
        (equal ?VAR (VariableExpressionFn ?SYM ?TYPE))
        (scope ?SCOPE ?VAR)
        (pointsTo ?SCOPE ?SYM ?VAL)
        (instance ?VAL ?TYPE))
    (equal ?VAL (ExpressionValueFn ?VAR)))
(=> 
    (and
        (equal ?VAR (VariableExpressionFn ?SYM ?TYPE))
        (scope ?SCOPE ?VAR)
        (executes ?VAR)
        (not (exists (?VAL) (pointsTo ?SCOPE ?SYM ?VAL)))
    (fault ?VAR (FaultFn "unknown symbol"))))
(=> 
    (and 
        (equal ?VAR (VariableExpressionFn ?SYM ?TYPE))
        (scope ?SCOPE ?VAR)
        (pointsTo ?SCOPE ?SYM ?VAL)
        (not (instance ?VAL ?TYPE)))
    (fault ?VAL (FaultFn "bad variable type expectation")))
