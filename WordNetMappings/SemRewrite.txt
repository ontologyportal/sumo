; Semantic Rewriting Rule set
; author: Adam Pease - adam.pease@ipsoft.com
; implements the semantic rewriting of CELT, as described in
;   Pease, A., and Li, J. (2010) Controlled English to Logic Translation. 
;   In Theory and Applications of Ontology, ed. Roberto Poli, 
;   Michael Healy, and Achilles Kameas, Springer, ISBN: 978-90-481-8846-8.
;  This software is released under the GNU Public License
; <http://www.gnu.org/copyleft/gpl.html>.

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Artifact) ==> (refers(?X,?Y)).
; e.g.,

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Communication) ==> (refers(?X,?Y)).
; e.g.,

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,ContentBearingObject) ==> (refers(?X,?Y)).
prep_about(?X,?Y), +sumo(ContentBearingObject,?X) ==> (refers(?X,?Y)).
; e.g.,

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Directing) ==> (refers(?X,?Y)).
; e.g., advice

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,EmotionalState) ==> (refers(?X,?Y)).
; e.g., alarm, anxiety

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C, FactualText) ==> (refers(?X,?Y)).
; e.g., announcement, documentary, letter, message, etc.

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,LinguisticExpression) ==> (refers(?X,?Y)).
; e.g.,

prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Proposition) ==> (refers(?X,?Y)).
; e.g., agreement

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; statives --------------

; agree - ReachingAgreement
; believe - believes Formula
; belong
; concern
; consist
; contain
; depend
; deserve
; disagree
; dislikes
; doubt
; feel
; fit
; hates

nsubj(?P,?A), dobj(?P,?O), +sumo(dislikes,?P) ==> (dislikes(?A,?O)).

; hear
; imagine
; impress
; include
; involve
; know
; like
; love
; matter
; mean
; measure
; mind
; need
; owe
; owns

nsubj(?P,?A), dobj(?P,?O), sumo(possesses,?P) ==> (possesses(?A,?O)).

; prefer
; promise
; realise
; recognise
; remember
; seem
; sound
; suppose
; surprise
; understand
; want
; weigh
; wish 
; writes
+sumo(?C,?X), isCELTclass(?C,ContentDevelopment) ==> (authors(?A,?X)).

;; measures

; Long, wide, deep, thick, tall, high, and old are the only adjectives used as measure words

nsubj(wide*,?S),  cop(wide*,is*),  sumo(?C,wide*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(width ?S (MeasureFn ?U ?V))}.
nsubj(deep*,?S),  cop(deep*,is*),  sumo(?C,deep*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(depth (TopFn ?S) (BottomFn ?S) ?X)}.
nsubj(long*,?S),  cop(long*,is*),  sumo(?C,long*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(length ?S (MeasureFn ?U ?V))}.
nsubj(thick*,?S), cop(thick*,is*), sumo(?C,thick*), unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(width ?S (MeasureFn ?U ?V))}.
nsubj(tall*,?S),  cop(tall*,is*),  sumo(?C,tall*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(height ?S (MeasureFn ?U ?V))}.
nsubj(high*,?S),  cop(high*,is*),  sumo(?C,high*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(height ?S (MeasureFn ?U ?V))}.
nsubj(old*,?S),   cop(old*,is*),   sumo(?C,old*),   unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(age ?S (MeasureFn ?U ?V))}.

nsubj(is*, ?S), npadvmod(wide*, ?U2),  advmod(is*,wide*),  sumo(?C,wide*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(width ?S (MeasureFn ?U ?V))}.
nsubj(is*, ?S), npadvmod(deep*, ?U2),  advmod(is*,deep*),  sumo(?C,deep*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(depth (TopFn ?S) (BottomFn ?S) ?X)}.
nsubj(is*, ?S), npadvmod(long*, ?U2),  advmod(is*,long*),  sumo(?C,long*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(length ?S (MeasureFn ?U ?V))}.
nsubj(is*, ?S), npadvmod(thick*, ?U2), advmod(is*,thick*), sumo(?C,thick*), unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(width ?S (MeasureFn ?U ?V))}.
nsubj(is*, ?S), npadvmod(tall*, ?U2),  advmod(is*,tall*),  sumo(?C,tall*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(height ?S (MeasureFn ?U ?V))}.
nsubj(is*, ?S), npadvmod(high*, ?U2),  advmod(is*,high*),  sumo(?C,high*),  unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(height ?S (MeasureFn ?U ?V))}.
nsubj(is*, ?S), npadvmod(old*, ?U2),   advmod(is*,old*),   sumo(?C,old*),   unit(?M,?U), value(?M,?V), measure(?S,?M) ==> {(age ?S (MeasureFn ?U ?V))}.

;; prepositions --------------

;{isCELTclass(?X,Person)} ==> (isCELTclass(?X,Person)).
;{isCELTclass(?X,Time)} ==> (isCELTclass(?X,Time)).
;{isCELTclass(?X,Object)} ==> (isCELTclass(?X,Time)).

prep_at(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (located(?X,?Y)).
prep_in(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Inside)}.
prep_inside(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Inside)}.
prep_outside(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Outside)}.
prep_on(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (located(?X,?Y)).
prep_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_towards(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_toward(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> {(EndFn ?X ?Y)}.

; prep_of(drink-4,water-6), sumo(Drinking,drink-4).
prep_of(?V,?Y), sumo(?C,?V), isSubclassOf(?C,Process) ==> (dobj(?V,?Y)).

prep_at(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).
prep_in(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).
prep_on(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).

prep_for(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Person) ==> (destination(?X,?Y)).
prep_for(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (duration(?X,?Y)).

prep_since(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (starts(?Y,?X)).

prep_through(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (duration(?X,?Y)).
prep_through(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (traverses(?X,?Y)).

prep_with(?X,?Y), +sumo(Human,?Y) ==> (agent(?X,?Y)).
prep_with(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Person) ==> (agent(?X,?Y)).
prep_with(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (instrument(?X,?Y)).

prep_across(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (traverses(?X,?Y)).

prep_within(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (properlyFills(?X,?Y)).
prep_into(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (properlyFills(?X,?Y)).

prep_from(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (origin(?X,?Y)).
prep_from(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (BeginFn(?X,?Y)).

prep_until(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (EndFn(?X,?Y)).


prep_after(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (greaterThan(?X,?Y)).
prep_before(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (lessThan(?X,?Y)).

nsubj(are*,?X), prep_about(are*,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> (refers(?X,?Y)).
nsubj(is*,?X), prep_about(is*,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> (refers(?X,?Y)).
nsubj(was*,?X), prep_about(was*,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> (refers(?X,?Y)).
nsubj(were*,?X), prep_about(were*,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> (refers(?X,?Y)).


prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Artifact) ==> (refers(?X,?Y)).
                 ; e.g.,

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Communication) ==> (refers(?X,?Y)).
                 ; e.g.,

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,ContentBearingObject) ==> (refers(?X,?Y)).
                 prep_about(?X,?Y), +sumo(ContentBearingObject,?X) ==> (refers(?X,?Y)).
                 ; e.g.,

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Directing) ==> (refers(?X,?Y)).
                 ; e.g., advice

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,EmotionalState) ==> (refers(?X,?Y)).
                 ; e.g., alarm, anxiety

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C, FactualText) ==> (refers(?X,?Y)).
                 ; e.g., announcement, documentary, letter, message, etc.

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,LinguisticExpression) ==> (refers(?X,?Y)).
                 ; e.g.,

                 prep_about(?X,?Y), +sumo(?C,?X), isSubclass(?C,Proposition) ==> (refers(?X,?Y)).
                 ; e.g., agreement


; prep_according_to
; prep_across_from
; prep_ahead_of

prep_ahead_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> {(earlier ?X (WhenFn ?Y))}.

; prep_along_with

prep_along_with(?X,?Y), +sumo(Human,?Y) ==> (agent(?X,?Y)).
prep_along_with(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Person) ==> (agent(?X,?Y)).

; prep_alongside_of

prep_alongside_of_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Near)}.

; prep_apart_from
; prep_as_for
; prep_as_from
; prep_as_of
; prep_as_per

prep_as_per(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Text) ==> (containsInformation(?X,?Y)).

; prep_as_to
; prep_aside_from
; prep_away_from
; prep_based_on
; prep_because_of
; prep_close_by

prep_close_by(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Near)}.

; prep_close_to

prep_close_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Near)}.

; prep_contrary_to
; prep_compared_to
; prep_compared_with
; prep_due_to

; prep_due_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process), +sumo(?C2,?X), isSubclass(?C2,Process) ==> {(causes ?X ?Y)}.

; prep_depending_on
; prep_except_for
; prep_exclusive_of
; prep_contrary_to
; prep_followed_by
; prep_inside_of

prep_inside_of(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(contains ?X ?Y)}.

; prep_instead_of
; prep_irrespective_of
; prep_next_to

prep_next_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Near)}.

; prep_near_to

prep_near_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y Near)}.

; prep_off_of
; prep_out_of
; prep_outside_of
; prep_owing_to
; pref_over

prep_over(?V,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?LOC ?Y Above) (located ?V ?LOC)}.

; prep_preliminary_to
; prep_preparatory_to
; prep_previous_to

prep_previous_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> {(earlier ?X (WhenFn ?Y))}.
prep_previous_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> {(earlier ?X ?Y)}.

; prep_prior_to

prep_prior_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> {(earlier ?X (WhenFn ?Y))}.
prep_prior_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> {(earlier ?X ?Y)}.

; prep_pursuant_to
; prep_regardless_of
; prep_subsequent_to

prep_prior_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process) ==> {(earlier (WhenFn ?Y) ?X)}.
prep_prior_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> {(earlier ?Y ?X)}.

; prep_such_as
; prep_thanks_to

; prep_thanks_to(?X,?Y), +sumo(?C,?Y), isSubclass(?C,Process), +sumo(?C2,?X), isSubclass(?C2,Process) ==> {(causes ?X ?Y)}.

; prep_together_with
; prep_by_means_of
; prep_in_accordance_with
; prep_in_addition_to
; prep_in_case_of

prep_in_front_of(?V,?Y), nsubj(?V,?Z) ==> {(and (equal ?F (FrontFn ?Y)) (orientation ?Z ?F Near))}.

; prep_in_lieu_of
; prep_in_place_of
; prep_in_spite_of
; prep_on_account_of
; prep_on_behalf_of
; prep_on_top_of

prep_on_top_of(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> {(orientation ?X ?Y On)}.

; prep_with_regard_to

; home downstairs downtown inside outside upstairs uptown

; approval of, awareness of, belief in, concern for, confusion about, desire for
; fondness for, grasp of, hatred of, hope for, interest in, love of
; need for, participation in, reason for, respect for, success in, understanding of
; afraid of, angry at, aware of, capable of, careless about, familiar with
; fond of, happy about, interested in, jealous of, made of, married to
; proud of, similar to, sorry for, sure of, tired of, worried about
; apologize for, ask about, ask for, belong to, bring up, care for, find out
; give up, grow up, look for, look forward to, look up, make up ,pay for
; prepare for, study for, talk about, think about, trust in ,work for, worry about 

; poss: possession modifier

poss(?R,?S), nsubj(?O,?R), cop(?O,?IS), sumo(?C,?R) ==>
 	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?O)).
poss(?R,?S), nsubj(?R,?O), cop(?O,?IS), sumo(?C,?R) ==>
 	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?O)).
poss(?R,?S), nsubj(?R,?O), cop(?R,?IS), sumo(?C,?R) ==>
 	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?O)).

sumo(?C,?R), nsubj(Who*,?R), cop(Who*,?IS), prep_of(?R,?S) ==>
	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?WHO)).

; (sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?O))

sumo(?C,?R), nsubj(?R,Who*), cop(?R,?IS), prep_of(?R,?O) ==>
	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?WHO)).

; sumo(brother,brother-5), nsubj(brother-5,John-3), cop(brother-5,is-2), prep_of(brother-5,Who-1)

sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,Who*) ==>
	(sumo(?C,?R), nsubj(?R,?S), cop(?R,?IS), prep_of(?R,?WHO)).

sumo(?C,customer*), nsubj(?R,?S), cop(customer*,is*), prep_of(?R,?O)  ==> {(customer ?S ?O)}.
sumo(?C,father*), nsubj(?R,?S), cop(father*,is*), prep_of(?R,?O)  ==> {(father ?S ?O)}.
sumo(?C,ancestor*), nsubj(?R,?S), cop(ancestor*,is*), prep_of(?R,?O)  ==> {(ancestor ?S ?O)}.
sumo(?C,aunt*), nsubj(?R,?S), cop(aunt*,is*), prep_of(?R,?O)  ==> {(aunt ?S ?O)}.
sumo(?C,cousin*), nsubj(?R,?S), cop(cousin*,is*), prep_of(?R,?O)  ==> {(cousin ?S ?O)}.
sumo(?C,grandfather*), nsubj(?R,?S), cop(grandfather*,is*), prep_of(?R,?O)  ==> {(grandfather ?S ?O)}.
sumo(?C,grandmother*), nsubj(?R,?S), cop(grandmother*,is*), prep_of(?R,?O)  ==> {(grandmother ?S ?O)}.
sumo(?C,nephew*), nsubj(?R,?S), cop(nephew*,is*), prep_of(?R,?O)  ==> {(nephew ?S ?O)}.
sumo(?C,niece*), nsubj(?R,?S), cop(niece*,is*), prep_of(?R,?O)  ==> {(niece ?S ?O)}.
sumo(?C,parent*), nsubj(?R,?S), cop(parent*,is*), prep_of(?R,?O)  ==> {(parent ?S ?O)}.
sumo(?C,sibling*), nsubj(?R,?S), cop(sibling*,is*), prep_of(?R,?O)  ==> {(sibling ?S ?O)}.
sumo(?C,brother*), nsubj(?R,?S), cop(brother*,is*), prep_of(?R,?O)  ==> {(brother ?S ?O)}.
sumo(?C,sister*), nsubj(?R,?S), cop(sister*,is*), prep_of(?R,?O)  ==> {(sister ?S ?O)}.
sumo(?C,uncle*), nsubj(?R,?S), cop(uncle*,is*), prep_of(?R,?O)  ==> {(uncle ?S ?O)}.

sumo(?C,owner*), nsubj(?R,?S), cop(owner*,is*), prep_of(?R,?O)  ==> {(possesses ?S ?O)}.
sumo(?C,administrator*), nsubj(?R,?S), cop(administrator*,is*), prep_of(?R,?O)  ==> {(administrator ?S ?O)}.

nsubj(?R,?S), cop(owner*,is*), prep_of(?R,?O)  ==> {(possesses ?S ?O)}.

;; catalog of dependency elements --------------

; adjectival complement
acomp(?P,?Y), +dobj(?P,?O) ==> (attribute(?O,?Y)).

; adverbial clause modifier
; HOL advcl(?X,?Y) ==> 

; adverbial modifier

;; question words ------------------------------

; Where does John go?
advmod(?V, Where*), +nsubj(go-4, John-3), sumo(?C,does*) ==> (destination(?V,?WH)).

; What did John do?
dobj(?V,What*), aux(?V,?did*), sumo(?X,?did*), nsubj(?V,?A) ==> (agent(?V,?A), instance(?V,?WH)).

; Why is John a student?
; advmod(is-2,Why-1), root(ROOT-0,is-2), nsubj(is-2,John-3), det(student-5,a-4), dep(is-2,student-5), sumo(student,student-5), sumo(Human,John-3)

; Why does John walk?
; advmod(walk-4,Why-1), aux(walk-4,does-2), nsubj(walk-4,John-3), root(ROOT-0,walk-4), sumo(causes,does-2), sumo(Human,John-3), sumo(Walking,walk-4)
advmod(?V,Why*), aux(?V,does*), +nsubj(?V,?A), sumo(?C,does*) ==> (causes(?X,?V)).

; When does John walk?
advmod(?V,When*), aux(?V,?does), sumo(?C,?V), +nsubj(?V,?A), sumo(?C,does*)  ==> {(and (agent ?V ?A) (instance ?V ?C) (equals ?WHEN (WhenFn ?V)}.

; Who moves the cart?
nsubj(?V,Who*) ==> {(instance ?WH Human) (agent ?V ?WH)}.

;; -------------------------------------

advmod(?V,?Y), nsubj(?V,?P), +sumo(Indoors,?Y) ==> {(located ?P ?INDOORS) (instance ?INDOORS Indoors) (exists (?BUILDING) (and (instance ?BUILDING Building) (orientation ?INDOORS ?BUILDING Inside)))}.

advmod(?V,?Y), nsubj(?V,?P), +sumo(Outdoors,?Y) ==> {(located ?P ?OUTDOORS) (instance ?OUTDOORS Outdoors) (not (exists (?BUILDING) (and (instance ?BUILDING Building) (orientation ?OUTDOORS ?BUILDING Inside))))}.
advmod(?X,?Y) ==> (attribute(?X,?Y)).

cop(?X,?Y), nsubj(?X,?P), +sumo(Indoors,?X) ==> {((located ?P ?INDOORS) (instance ?INDOORS Indoors) (exists (?BUILDING) (and (instance ?BUILDING Building) (orientation ?INDOORS ?BUILDING Inside)))}.

cop(?X,?Y), nsubj(?X,?P), +sumo(Outdoors,?X) ==> {(located ?P ?OUTDOORS) (instance ?OUTDOORS Outdoors) (not (exists (?BUILDING) (and (instance ?BUILDING Building) (orientation ?OUTDOORS ?BUILDING Inside))))}.

advmod(?X,?Y) ==> (attribute(?X,?Y)).
; agent - complement of a passive verb
; agent(?X,?Y) ==> (agent(?X,?Y)).

; adjectival modifier
amod(?X,?Y), sumo(?C,?Y) ==> (attribute(?X,?C)).
amod(?X,?Y) ==> (attribute(?X,?Y)).

; appositional modifier
appos(?X,?Y) ==> (equals(?X,?Y)).

;; helper verbs ----------------------------

; John takes a walk.
; nsubj(takes-2,John-1), root(ROOT-0,takes-2), det(walk-4,a-3), dobj(takes-2,walk-4), sumo(Human,John-1), sumo(agent,takes-2), sumo(Walking,walk-4)

; John took a walk
; nsubj(took-2,John-1), root(ROOT-0,took-2), det(walk-4,a-3), dobj(took-2,walk-4), sumo(agent,took-2), sumo(Human,John-1), sumo(Walking,walk-4)

; John will take a walk.
; nsubj(take-3,John-1), aux(take-3,will-2), root(ROOT-0,take-3), det(walk-5,a-4), dobj(take-3,walk-5), sumo(Human,John-1), sumo(Walking,walk-5)

; John has taken a walk
; nsubj(taken-3,John-1), aux(taken-3,has-2), root(ROOT-0,taken-3), det(walk-5,a-4), dobj(taken-3,walk-5), sumo(agent,taken-3), sumo(Human,John-1), sumo(Walking,walk-5)

nsubj(taken*,?S), aux(taken*,has*), dobj(taken*,?V), sumo(?X,taken*), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), past(?V,?DUMMY), sumo(?C,?V)).
nsubj(take*,?S), aux(take*,will*), dobj(take*,?V), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), future(?V,?DUMMY), sumo(?C,?V)).
nsubj(take*,?S), dobj(take*,?V), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), sumo(?C,?V)).
nsubj(takes*,?S), dobj(takes*,?V), sumo(?C,?V), isSubclass(?C,Process), sumo(?T,takes*) ==> (nsubj(?V,?S), sumo(?C,?V)).
nsubj(took*,?S), dobj(took*,?V), sumo(?C,?V), isSubclass(?C,Process), sumo(?T,took*) ==> (nsubj(?V,?S), past(?V,?DUMMY), sumo(?C,?V)).

nsubj(made*,?S), aux(made*,has*), dobj(made*,?V), sumo(?X,made*), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), past(?V,?DUMMY), sumo(?C,?V)).
nsubj(make*,?S), aux(make*,will*), dobj(make*,?V), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), future(?V,?DUMMY), sumo(?C,?V)).
nsubj(make*,?S), dobj(make*,?V), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), sumo(?C,?V)).
nsubj(makes*,?S), dobj(makes*,?V), sumo(?C,?V), isSubclass(?C,Process), sumo(?T,makes*) ==> (nsubj(?V,?S), sumo(?C,?V)).
; John made a decision.
; nsubj(made-2,John-1), dobj(made-2,decision-4), sumo(Deciding,decision-4), 
nsubj(made*,?S), dobj(made*,?V), sumo(?C,?V), isSubclass(?C,Process) ==> (nsubj(?V,?S), past(?V,?DUMMY), sumo(?C,?V)).

;; -------------------------------------

; auxilliary - be (am, are, is, was, were, being, been), can, could, dare, do (does, did), have (has, had, having), may, might, must, need, ought, shall, should, will, would

aux(?V,did*), sumo(?C,did*), +sumo(?C2,?V), isSubclass(?C2,Process) ==> (past(?V,?DUMMY)).
aux(?V,does*), sumo(?C,does*), +sumo(?C2,?V), isSubclass(?C2,Process) ==> !.
aux(?V,has*) ==> (past(?V,?DUMMY)).
aux(?V,had*) ==> (past(?V,?DUMMY)).
aux(?V,will*) ==> (future(?V,?DUMMY)).
aux(?V,may*) ==> (possible(?V,?DUMMY)).
aux(?V,might*) ==> (possible(?V,?DUMMY)).
aux(?V,can*) ==> (possible(?V,?DUMMY)).
aux(?V,could*) ==> (possible(?V,?DUMMY)).
aux(?V,must*) ==> (necessary(?V,?DUMMY)).
aux(?V,should*) ==> (possible(?V,?DUMMY)).
aux(?V,should*) ==> (possible(?V,?DUMMY)).
aux(?V,must*) ==> (possible(?V,?DUMMY)).

; passive auxiliary
; auxpass(?X,?Y), -past(?X,?DUMMY) ==> (past(?X,?DUMMY)).

; coordination

; clausal complement
; HOL

; clausal subject
; HOL

; clausal passive subject
; HOL

; copula

attribute(?X,?Y), isInstance(?X,Human), isInstance(?Y,Nation) ==> (citizen(?X,?Y)).
cop(?A,was-15), det(?A,?DET), nsubj(?A,?S), sumo(?I,?A), isInstance(?I,Attribute) ==> (attribute(?I,?S)).
nsubj(?X,?A), cop(?X,?Y), +sumo(?C,?X), isInstanceOf(?C,Attribute) ==> (attribute(?X,?Y)).
nsubj(?X,?A), cop(?X,?Y), +sumo(?C,?X) ==> (instance(?X,?C)).

nsubjpass(?X,?Y) ==> (patient(?X,?Y)).

; det(?X,What*), sumo(?O,?X)  ==> (instance(?WHAT,?O)).
; det(?X,Which*), sumo(?O,?X)  ==> (instance(?WHICH,?O)).
; det(?X,Some*)
; det(?X,All*)

; discourse element
; ??

dobj(?E,?Y) ==> (patient(?E,?Y)).

; expletive - not needed?

; goes with

; indirect object
iobj(?X,?Y) ==> (patient(?E,?Y)).

; marker
; mwe

; negation modifier
; note this needs to wrap the entire expression
neg(?V,?N), sumo(?C,N) ==> (not(?V,?DUMMY)).
neg(?V,?Y) ==> (not(?X,?DUMMY)).

; noun compound modifier
; noun phrase as adverbial modifer

; nominal subject - copula handles a special case of this
nsubj(?E,?X) ==> (agent(?E,?X)).

nsubjpass(?E,?Y) ==> (patient(?E,?Y)).

quantmod(?X,About*), num(?O,?X) ==> (approximateValue(?X,countid), num(?O,countid)).

num(?O,one*) ==> (num(?O,1)).
num(?O,two*) ==> (num(?O,2)).
num(?O,three*) ==> (num(?O,3)).
num(?O,four*) ==> (num(?O,4)).
num(?O,five*) ==> (num(?O,5)).
num(?O,six*) ==> (num(?O,6)).
num(?O,seven*) ==> (num(?O,7)).
num(?O,eight*) ==> (num(?O,8)).
num(?O,nine*) ==> (num(?O,9)).
num(?O,ten*) ==> (num(?O,10)).
num(?O,eleven*) ==> (num(?O,11)).
num(?O,twelve*) ==> (num(?O,12)).
num(?O,thirteen*) ==> (num(?O,13)).
num(?O,fourteen*) ==> (num(?O,14)).
num(?O,fifteen*) ==> (num(?O,15)).
num(?O,sixteen*) ==> (num(?O,16)).
num(?O,seventeen*) ==> (num(?O,17)).
num(?O,eighteen*) ==> (num(?O,18)).
num(?O,nineteen*) ==> (num(?O,19)).
num(?O,twenty*) ==> (num(?O,20)).

num(?O,?N), +sumo(?C,?O) ==> (instance(?O,Collection), membersType(?O,?C), membersCount(?O,?N)).
num(?dollars*,?N) ==> {(measure ?dollars* (MeasureFn ?NUnitedStatesDollar))}.
; current language doesn't allow functions

; element of compound number

; parataxis

; pcomp - prepositional complement

; pobj - object of a preposition

; preconj: preconjunct - can be ignored?

; predet predeterminer
; looks like another quantifier 
predet(?X,?Y) ==> (det(?X,?Y)).

; prep: prepositional modifier

; prepc: prepositional clausal modifier
prepc_without(?X,?Y) ==> (not(?Y,?DUMMY)).

; prt: phrasal verb particle

; punct: punctuation

; quantmod: quantifier phrase modifer
; has to go above

; ref: reference - not in the collapsed model?

; root 

root(?X,?Y) ==> !.

; tmod: temporal modifier
tmod(?V,?T) ==> (during(?V,?T)).

; vmod: reduced non-finite verbal modifier

; xcomp: open clausal complement

; xsubj controlling subject


;; WSD: most polysemous

; light - 114
; run - 110
; play - 100
; make - 97
; set - 87
; give - 86
; point - 80
; take - 77
; line - 72
; get - 67
; roll - 65
; good - 63
; mark - 62
; go - 60
; dead - 60

;; -------------------------------
;; time and date

day(?T,?D), month(?T,?M), year(?T,?Y), time(?V,?T) ==> {(time ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
month(?T,?M), year(?T,?Y), time(?V,?T) ==> {(time ?V (MonthFn ?M (YearFn ?Y)))}.
year(?T,?Y), time(?V,?T) ==> {(time ?V (YearFn ?Y))}.
day(?T,?D), month(?T,?M), time(?V,?T) ==> {(time ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
day(?T,?D), time(?V,?T) ==> {(time ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.

day(?T,?D), month(?T,?M), year(?T,?Y), BirthDate(?V,?T) ==> {(birthdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
month(?T,?M), year(?T,?Y), BirthDate(?V,?T) ==> {(birthdate ?V (MonthFn ?M (YearFn ?Y)))}.
year(?T,?Y), BirthDate(?V,?T) ==> {(birthdate ?V (YearFn ?Y))}.
day(?T,?D), month(?T,?M), BirthDate(?V,?T) ==> {(birthdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
day(?T,?D), BirthDate(?V,?T) ==> {(birthdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.

day(?T,?D), month(?T,?M), year(?T,?Y), DeathDate(?V,?T) ==> {(deathdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
month(?T,?M), year(?T,?Y), DeathDate(?V,?T) ==> {(birthdate ?V (MonthFn ?M (YearFn ?Y)))}.
year(?T,?Y), DeathDate(?V,?T) ==> {(deathdate ?V (YearFn ?Y))}.
day(?T,?D), month(?T,?M), DeathDate(?V,?T) ==> {(deathdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.
day(?T,?D), DeathDate(?V,?T) ==> {(deathdate ?V (DayFn ?D (MonthFn ?M (YearFn ?Y))))}.

;; -------------------------------
sumo(?O,?X) ==> (instance(?X,?O)).

agent(?X,?Y) ==> {(agent ?X ?Y)}.
approximateValue(?X,?Y) ==> {(approximateValue ?X ?Y)}.
authors(?X,?Y) ==> {(authors ?X ?Y)}.
attribute(?X,?Y) ==> {(attribute ?X ?Y)}.
causes(?X,?Y) ==> {(causes ?X ?Y)}.
citizen(?X,?Y) ==> {(citizen ?X ?Y)}.
destination(?X,?Y) ==> {(destination ?X ?Y)}.
dislikes(?X,?Y) ==> {(dislikes ?X ?Y)}.
duration(?X,?Y) ==> {(duration ?X ?Y)}.
greaterThan(?X,?Y) ==> {(greaterThan ?X ?Y)}.
instance(?X,?Y) ==> {(instance ?X ?Y)}.
located(?X,?Y) ==> {(located ?X ?Y)}.
membersType(?X,?Y) ==> {(membersType ?X ?Y)}.
membersCount(?X,?Y) ==> {(membersCount ?X ?Y)}.
names(?X,?Y) ==> {(names ?X ?Y)}.
lessThan(?X,?Y) ==> {(lessThan ?X ?Y)}.
;orientation(?X,?Y,?Z) ==> {(orientation ?X ?Y ?Z)}.
origin(?X,?Y) ==> {(origin ?X ?Y)}.
patient(?X,?Y) ==> {(patient ?X ?Y)}.
properlyFills(?X,?Y) ==> {(properlyFills ?X ?Y)}.
possesses(?X,?Y) ==> {(possesses ?X ?Y)}.
refers(?X,?Y) ==> {(refers ?X ?Y)}.
traverses(?X,?Y) ==> {(traverses ?X ?Y)}.
time(?X,?Y) ==> {(time ?X ?Y)}.
BirthDate(?X,?Y) ==> {(birthdate ?X ?Y)}.
DeathDate(?X,?Y) ==> {(deathdate ?X ?Y)}.
past(?V,DUMMY) ==> {(earlier (WhenFn ?V) Now)}.
future(?V,DUMMY) ==> {(earlier Now (WhenFn ?V))}.

; time TimeMeasure, Process
; person Human, OccupationalRole, SocialRole
; object all others

; mass Substance, Food, and special words such as
;      money/furniture/data/life/beauty/truth/crime/law/education
; count all others
